#pragma once
#include <stencil/stencil.h>
// SECTION START: DECLARATIONS
#if true

namespace Objects
{
struct SimpleObject1;
struct ListObject;
struct DictObject;
struct List;
struct SimpleObject2;
struct NestedObject;
struct SelfNested;
}    // namespace Objects

template <> struct Stencil::TypeTraits<Objects::SimpleObject1>;
template <> struct Stencil::TypeTraits<Objects::ListObject>;
template <> struct Stencil::TypeTraits<Objects::DictObject>;
template <> struct Stencil::TypeTraits<Objects::List>;
template <> struct Stencil::TypeTraits<Objects::SimpleObject2>;
template <> struct Stencil::TypeTraits<Objects::NestedObject>;
template <> struct Stencil::TypeTraits<Objects::SelfNested>;
#endif
// SECTION END: DECLARATIONS

// SECTION START: Definitions
#if true
namespace Objects
{
struct SimpleObject1 :
    public ::Stencil::OptionalPropsT<::Objects::SimpleObject1>,
    public ::Stencil::TimestampedT<::Objects::SimpleObject1>,
    public Stencil::StructT<SimpleObject1>
{
    int32_t val1 = {};
    uint32_t val2 = {};
    uint8_t val3 = {};
    shared_string val4 = {};
    double val5 = {};
};
struct ListObject :
    public ::Stencil::TimestampedT<::Objects::ListObject>,
    public Stencil::StructT<ListObject>
{
    uint32_t value = {};
    ::Objects::SimpleObject1 obj1 = {};
};
struct DictObject :
    public Stencil::StructT<DictObject>
{
    std::unordered_map<uint32_t, ::Objects::SimpleObject1> dictobj = {};
    std::unordered_map<shared_string, Stencil::Timestamp> dictval = {};
    std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>> dictdict = {};
};
struct List :
    public ::Stencil::TimestampedT<::Objects::List>,
    public Stencil::StructT<List>
{
    std::vector<::Objects::ListObject> listobj = {};
};
struct SimpleObject2 :
    public ::Stencil::OptionalPropsT<::Objects::SimpleObject2>,
    public ::Stencil::TimestampedT<::Objects::SimpleObject2>,
    public Stencil::StructT<SimpleObject2>
{
    bool val1 = {};
    double val2 = {};
    std::array<char, 8> val3 = {};
    Stencil::Timestamp val4 = {};
    uint64_t val5 = {};
    int64_t val6 = {};
    uint16_t val7 = {};
    int16_t val8 = {};
};
struct NestedObject :
    public ::Stencil::TimestampedT<::Objects::NestedObject>,
    public Stencil::StructT<NestedObject>
{
    ::Objects::SimpleObject1 obj1 = {};
    ::Objects::SimpleObject2 obj2 = {};
    ::Objects::ListObject obj3 = {};
    ::Objects::DictObject dict1 = {};
    ::Objects::List list1 = {};
};
struct SelfNested :
    public Stencil::StructT<SelfNested>
{
    ::Objects::SimpleObject1 obj1 = {};
    Stencil::Ref<::Objects::SelfNested> self = {};
};
}    // namespace Objects
#endif

// SECTION END: Definitions

// SECTION START: Template specializations
#if true

// SECTION:

template <> struct Stencil::TypeTraits<Objects::SimpleObject1>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>
{
    enum class Fields
    {
        Invalid,
        Field_val1
,        Field_val2
,        Field_val3
,        Field_val4
,        Field_val5
    };

    struct Field_val1T
    {};
    struct Field_val2T
    {};
    struct Field_val3T
    {};
    struct Field_val4T
    {};
    struct Field_val5T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val2T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val2T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val2"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val2";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val2T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val2T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val2);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val2) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val3T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val3T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val3"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val3";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val3T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val3T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val3);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val3) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val4T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val4T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val4"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val4";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val4T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val4T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val4);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val4) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val5T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val5T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val5"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val5";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val5T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Field_val5T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val5);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val5) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "val1"
,        "val2"
,        "val3"
,        "val4"
,        "val5"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::SimpleObject1, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::SimpleObject1>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState val1 = {Fields::Field_val1};
        ElemTxnState val2 = {Fields::Field_val2};
        ElemTxnState val3 = {Fields::Field_val3};
        ElemTxnState val4 = {Fields::Field_val4};
        ElemTxnState val5 = {Fields::Field_val5};
    };

    using Txn               = Stencil::Transaction<Objects::SimpleObject1, TContainer>;
    using ElemType          = Objects::SimpleObject1;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_val1 = Stencil::Transaction<int32_t, Txn>;
    using Transaction_val2 = Stencil::Transaction<uint32_t, Txn>;
    using Transaction_val3 = Stencil::Transaction<uint8_t, Txn>;
    using Transaction_val4 = Stencil::Transaction<shared_string, Txn>;
    using Transaction_val5 = Stencil::Transaction<double, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_val1::TxnState val1{};
        typename Transaction_val2::TxnState val2{};
        typename Transaction_val3::TxnState val3{};
        typename Transaction_val4::TxnState val4{};
        typename Transaction_val5::TxnState val5{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_val1))
        {
            auto txn = val1();
            lambda(Fields::Field_val1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val1))
        {
            auto txn = val1();
            lambda(Fields::Field_val1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val2))
        {
            auto txn = val2();
            lambda(Fields::Field_val2, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val2))
        {
            auto txn = val2();
            lambda(Fields::Field_val2, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val3))
        {
            auto txn = val3();
            lambda(Fields::Field_val3, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val3))
        {
            auto txn = val3();
            lambda(Fields::Field_val3, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val4))
        {
            auto txn = val4();
            lambda(Fields::Field_val4, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val4))
        {
            auto txn = val4();
            lambda(Fields::Field_val4, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val5))
        {
            auto txn = val5();
            lambda(Fields::Field_val5, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val5))
        {
            auto txn = val5();
            lambda(Fields::Field_val5, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto val1()
    {
        return Stencil::CreateTransaction<Transaction_val1>(_elemState.val1, _txnStateForElem.val1, *this, _elem.val1);
    }

    auto val2()
    {
        return Stencil::CreateTransaction<Transaction_val2>(_elemState.val2, _txnStateForElem.val2, *this, _elem.val2);
    }

    auto val3()
    {
        return Stencil::CreateTransaction<Transaction_val3>(_elemState.val3, _txnStateForElem.val3, *this, _elem.val3);
    }

    auto val4()
    {
        return Stencil::CreateTransaction<Transaction_val4>(_elemState.val4, _txnStateForElem.val4, *this, _elem.val4);
    }

    auto val5()
    {
        return Stencil::CreateTransaction<Transaction_val5>(_elemState.val5, _txnStateForElem.val5, *this, _elem.val5);
    }

    void set_val1(int32_t&& val)
    {
        auto subtxn = val1();
        subtxn.Assign(std::forward<int32_t>(val));
    }

    void set_val2(uint32_t&& val)
    {
        auto subtxn = val2();
        subtxn.Assign(std::forward<uint32_t>(val));
    }

    void set_val3(uint8_t&& val)
    {
        auto subtxn = val3();
        subtxn.Assign(std::forward<uint8_t>(val));
    }

    void set_val4(shared_string&& val)
    {
        auto subtxn = val4();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_val5(double&& val)
    {
        auto subtxn = val5();
        subtxn.Assign(std::forward<double>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_val1:
        {
            auto txn = val1();
            return lambda(txn);
        }
        case Fields::Field_val2:
        {
            auto txn = val2();
            return lambda(txn);
        }
        case Fields::Field_val3:
        {
            auto txn = val3();
            return lambda(txn);
        }
        case Fields::Field_val4:
        {
            auto txn = val4();
            return lambda(txn);
        }
        case Fields::Field_val5:
        {
            auto txn = val5();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = val1();
            lambda(Traits::Field_val1T{}, txn, Elem().val1);
        }
        {
            auto txn = val2();
            lambda(Traits::Field_val2T{}, txn, Elem().val2);
        }
        {
            auto txn = val3();
            lambda(Traits::Field_val3T{}, txn, Elem().val3);
        }
        {
            auto txn = val4();
            lambda(Traits::Field_val4T{}, txn, Elem().val4);
        }
        {
            auto txn = val5();
            lambda(Traits::Field_val5T{}, txn, Elem().val5);
        }
    }
};

template <> struct Stencil::Visitor<Objects::SimpleObject1> : Stencil::VisitorT<Objects::SimpleObject1>
{
    using TData  = Objects::SimpleObject1;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_val1: return lambda(obj.val1);
        case Fields::Field_val2: return lambda(obj.val2);
        case Fields::Field_val3: return lambda(obj.val3);
        case Fields::Field_val4: return lambda(obj.val4);
        case Fields::Field_val5: return lambda(obj.val5);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_val1T{}, obj.val1);
        lambda(Traits::Field_val2T{}, obj.val2);
        lambda(Traits::Field_val3T{}, obj.val3);
        lambda(Traits::Field_val4T{}, obj.val4);
        lambda(Traits::Field_val5T{}, obj.val5);
    }
};

template <> struct Stencil::Comparator<Objects::SimpleObject1, Objects::SimpleObject1>
{
    using ThisType = Objects::SimpleObject1;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.val1, obj2.val1)
               && Stencil::AreEqual(obj1.val2, obj2.val2)
               && Stencil::AreEqual(obj1.val3, obj2.val3)
               && Stencil::AreEqual(obj1.val4, obj2.val4)
               && Stencil::AreEqual(obj1.val5, obj2.val5)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::SimpleObject1> :
    public Stencil::Database::Record<::Stencil::OptionalPropsT<::Objects::SimpleObject1>>,
    public Stencil::Database::Record<::Stencil::TimestampedT<::Objects::SimpleObject1>>,
    public Stencil::Database::RecordT<Objects::SimpleObject1>
{
    public:
    Stencil::Database::RecordNest<int32_t>::Type val1{};
    Stencil::Database::RecordNest<uint32_t>::Type val2{};
    Stencil::Database::RecordNest<uint8_t>::Type val3{};
    Stencil::Database::RecordNest<shared_string>::Type val4{};
    Stencil::Database::RecordNest<double>::Type val5{};
};

template <> struct Stencil::Database::RecordTraits<Objects::SimpleObject1>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<int32_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<uint32_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<uint8_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<double>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::OptionalPropsT<::Objects::SimpleObject1>>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::TimestampedT<::Objects::SimpleObject1>>::RecordTypes,
        std::tuple<Objects::SimpleObject1>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::SimpleObject1>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::SimpleObject1 const&                      obj,
                              Stencil::Database::Record<Objects::SimpleObject1>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::OptionalPropsT<::Objects::SimpleObject1> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::OptionalPropsT<::Objects::SimpleObject1>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::TimestampedT<::Objects::SimpleObject1> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::TimestampedT<::Objects::SimpleObject1>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val1, rec.val1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val2, rec.val2);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val3, rec.val3);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val4, rec.val4);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val5, rec.val5);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::SimpleObject1>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::SimpleObject1>>
{
    using TData  = Objects::SimpleObject1;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_val1: return lambda(obj.val1);
        case Fields::Field_val2: return lambda(obj.val2);
        case Fields::Field_val3: return lambda(obj.val3);
        case Fields::Field_val4: return lambda(obj.val4);
        case Fields::Field_val5: return lambda(obj.val5);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_val1T{}, obj.val1);
        lambda(Traits::Field_val2T{}, obj.val2);
        lambda(Traits::Field_val3T{}, obj.val3);
        lambda(Traits::Field_val4T{}, obj.val4);
        lambda(Traits::Field_val5T{}, obj.val5);
    }
};

template <> struct Stencil::TypeTraits<Objects::ListObject>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::ListObject>
{
    enum class Fields
    {
        Invalid,
        Field_value
,        Field_obj1
    };

    struct Field_valueT
    {};
    struct Field_obj1T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_valueT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_valueT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "value"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "value";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_valueT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_valueT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_value);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_value) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_obj1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_obj1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "obj1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "obj1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_obj1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Field_obj1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_obj1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_obj1) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "value"
,        "obj1"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::ListObject>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::ListObject, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::ListObject>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState value = {Fields::Field_value};
        ElemTxnState obj1 = {Fields::Field_obj1};
    };

    using Txn               = Stencil::Transaction<Objects::ListObject, TContainer>;
    using ElemType          = Objects::ListObject;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_value = Stencil::Transaction<uint32_t, Txn>;
    using Transaction_obj1 = Stencil::Transaction<::Objects::SimpleObject1, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_value::TxnState value{};
        typename Transaction_obj1::TxnState obj1{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_value))
        {
            auto txn = value();
            lambda(Fields::Field_value, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_value))
        {
            auto txn = value();
            lambda(Fields::Field_value, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto value()
    {
        return Stencil::CreateTransaction<Transaction_value>(_elemState.value, _txnStateForElem.value, *this, _elem.value);
    }

    auto obj1()
    {
        return Stencil::CreateTransaction<Transaction_obj1>(_elemState.obj1, _txnStateForElem.obj1, *this, _elem.obj1);
    }

    void set_value(uint32_t&& val)
    {
        auto subtxn = value();
        subtxn.Assign(std::forward<uint32_t>(val));
    }

    void set_obj1(::Objects::SimpleObject1&& val)
    {
        auto subtxn = obj1();
        subtxn.Assign(std::forward<::Objects::SimpleObject1>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_value:
        {
            auto txn = value();
            return lambda(txn);
        }
        case Fields::Field_obj1:
        {
            auto txn = obj1();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = value();
            lambda(Traits::Field_valueT{}, txn, Elem().value);
        }
        {
            auto txn = obj1();
            lambda(Traits::Field_obj1T{}, txn, Elem().obj1);
        }
    }
};

template <> struct Stencil::Visitor<Objects::ListObject> : Stencil::VisitorT<Objects::ListObject>
{
    using TData  = Objects::ListObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_value: return lambda(obj.value);
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_valueT{}, obj.value);
        lambda(Traits::Field_obj1T{}, obj.obj1);
    }
};

template <> struct Stencil::Comparator<Objects::ListObject, Objects::ListObject>
{
    using ThisType = Objects::ListObject;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.value, obj2.value)
               && Stencil::AreEqual(obj1.obj1, obj2.obj1)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::ListObject> :
    public Stencil::Database::Record<::Stencil::TimestampedT<::Objects::ListObject>>,
    public Stencil::Database::RecordT<Objects::ListObject>
{
    public:
    Stencil::Database::RecordNest<uint32_t>::Type value{};
    Stencil::Database::RecordNest<::Objects::SimpleObject1>::Type obj1{};
};

template <> struct Stencil::Database::RecordTraits<Objects::ListObject>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<uint32_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Objects::SimpleObject1>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::TimestampedT<::Objects::ListObject>>::RecordTypes,
        std::tuple<Objects::ListObject>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::ListObject>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::ListObject const&                      obj,
                              Stencil::Database::Record<Objects::ListObject>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::TimestampedT<::Objects::ListObject> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::TimestampedT<::Objects::ListObject>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.value, rec.value);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.obj1, rec.obj1);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::ListObject>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::ListObject>>
{
    using TData  = Objects::ListObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_value: return lambda(obj.value);
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_valueT{}, obj.value);
        lambda(Traits::Field_obj1T{}, obj.obj1);
    }
};

template <> struct Stencil::TypeTraits<Objects::DictObject>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::DictObject>
{
    enum class Fields
    {
        Invalid,
        Field_dictobj
,        Field_dictval
,        Field_dictdict
    };

    struct Field_dictobjT
    {};
    struct Field_dictvalT
    {};
    struct Field_dictdictT
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictobjT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictobjT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "dictobj"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "dictobj";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictobjT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictobjT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_dictobj);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_dictobj) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictvalT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictvalT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "dictval"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "dictval";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictvalT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictvalT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_dictval);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_dictval) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictdictT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictdictT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "dictdict"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "dictdict";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictdictT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Field_dictdictT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_dictdict);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_dictdict) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "dictobj"
,        "dictval"
,        "dictdict"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::DictObject>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::DictObject, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::DictObject>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState dictobj = {Fields::Field_dictobj};
        ElemTxnState dictval = {Fields::Field_dictval};
        ElemTxnState dictdict = {Fields::Field_dictdict};
    };

    using Txn               = Stencil::Transaction<Objects::DictObject, TContainer>;
    using ElemType          = Objects::DictObject;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_dictobj = Stencil::Transaction<std::unordered_map<uint32_t, ::Objects::SimpleObject1>, Txn>;
    using Transaction_dictval = Stencil::Transaction<std::unordered_map<shared_string, Stencil::Timestamp>, Txn>;
    using Transaction_dictdict = Stencil::Transaction<std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_dictobj::TxnState dictobj{};
        typename Transaction_dictval::TxnState dictval{};
        typename Transaction_dictdict::TxnState dictdict{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_dictobj))
        {
            auto txn = dictobj();
            lambda(Fields::Field_dictobj, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_dictobj))
        {
            auto txn = dictobj();
            lambda(Fields::Field_dictobj, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_dictval))
        {
            auto txn = dictval();
            lambda(Fields::Field_dictval, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_dictval))
        {
            auto txn = dictval();
            lambda(Fields::Field_dictval, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_dictdict))
        {
            auto txn = dictdict();
            lambda(Fields::Field_dictdict, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_dictdict))
        {
            auto txn = dictdict();
            lambda(Fields::Field_dictdict, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto dictobj()
    {
        return Stencil::CreateTransaction<Transaction_dictobj>(_elemState.dictobj, _txnStateForElem.dictobj, *this, _elem.dictobj);
    }

    auto dictval()
    {
        return Stencil::CreateTransaction<Transaction_dictval>(_elemState.dictval, _txnStateForElem.dictval, *this, _elem.dictval);
    }

    auto dictdict()
    {
        return Stencil::CreateTransaction<Transaction_dictdict>(_elemState.dictdict, _txnStateForElem.dictdict, *this, _elem.dictdict);
    }

    void set_dictobj(std::unordered_map<uint32_t, ::Objects::SimpleObject1>&& val)
    {
        auto subtxn = dictobj();
        subtxn.Assign(std::forward<std::unordered_map<uint32_t, ::Objects::SimpleObject1>>(val));
    }

    void set_dictval(std::unordered_map<shared_string, Stencil::Timestamp>&& val)
    {
        auto subtxn = dictval();
        subtxn.Assign(std::forward<std::unordered_map<shared_string, Stencil::Timestamp>>(val));
    }

    void set_dictdict(std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>>&& val)
    {
        auto subtxn = dictdict();
        subtxn.Assign(std::forward<std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>>>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_dictobj:
        {
            auto txn = dictobj();
            return lambda(txn);
        }
        case Fields::Field_dictval:
        {
            auto txn = dictval();
            return lambda(txn);
        }
        case Fields::Field_dictdict:
        {
            auto txn = dictdict();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = dictobj();
            lambda(Traits::Field_dictobjT{}, txn, Elem().dictobj);
        }
        {
            auto txn = dictval();
            lambda(Traits::Field_dictvalT{}, txn, Elem().dictval);
        }
        {
            auto txn = dictdict();
            lambda(Traits::Field_dictdictT{}, txn, Elem().dictdict);
        }
    }
};

template <> struct Stencil::Visitor<Objects::DictObject> : Stencil::VisitorT<Objects::DictObject>
{
    using TData  = Objects::DictObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_dictobj: return lambda(obj.dictobj);
        case Fields::Field_dictval: return lambda(obj.dictval);
        case Fields::Field_dictdict: return lambda(obj.dictdict);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_dictobjT{}, obj.dictobj);
        lambda(Traits::Field_dictvalT{}, obj.dictval);
        lambda(Traits::Field_dictdictT{}, obj.dictdict);
    }
};

template <> struct Stencil::Comparator<Objects::DictObject, Objects::DictObject>
{
    using ThisType = Objects::DictObject;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.dictobj, obj2.dictobj)
               && Stencil::AreEqual(obj1.dictval, obj2.dictval)
               && Stencil::AreEqual(obj1.dictdict, obj2.dictdict)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::DictObject> :
    public Stencil::Database::RecordT<Objects::DictObject>
{
    public:
    Stencil::Database::RecordNest<std::unordered_map<uint32_t, ::Objects::SimpleObject1>>::Type dictobj{};
    Stencil::Database::RecordNest<std::unordered_map<shared_string, Stencil::Timestamp>>::Type dictval{};
    Stencil::Database::RecordNest<std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>>>::Type dictdict{};
};

template <> struct Stencil::Database::RecordTraits<Objects::DictObject>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<std::unordered_map<uint32_t, ::Objects::SimpleObject1>>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::unordered_map<shared_string, Stencil::Timestamp>>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::unordered_map<uint32_t, std::unordered_map<uint32_t, ::Objects::SimpleObject1>>>::RecordTypes,
        std::tuple<Objects::DictObject>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::DictObject>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::DictObject const&                      obj,
                              Stencil::Database::Record<Objects::DictObject>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.dictobj, rec.dictobj);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.dictval, rec.dictval);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.dictdict, rec.dictdict);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::DictObject>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::DictObject>>
{
    using TData  = Objects::DictObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_dictobj: return lambda(obj.dictobj);
        case Fields::Field_dictval: return lambda(obj.dictval);
        case Fields::Field_dictdict: return lambda(obj.dictdict);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_dictobjT{}, obj.dictobj);
        lambda(Traits::Field_dictvalT{}, obj.dictval);
        lambda(Traits::Field_dictdictT{}, obj.dictdict);
    }
};

template <> struct Stencil::TypeTraits<Objects::List>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::List>
{
    enum class Fields
    {
        Invalid,
        Field_listobj
    };

    struct Field_listobjT
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::List>::Field_listobjT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::List>::Field_listobjT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "listobj"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "listobj";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::List>::Field_listobjT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::List>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::List>::Field_listobjT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_listobj);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_listobj) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::List>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::List>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "listobj"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::List>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::List>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::List, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::List>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState listobj = {Fields::Field_listobj};
    };

    using Txn               = Stencil::Transaction<Objects::List, TContainer>;
    using ElemType          = Objects::List;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_listobj = Stencil::Transaction<std::vector<::Objects::ListObject>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_listobj::TxnState listobj{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_listobj))
        {
            auto txn = listobj();
            lambda(Fields::Field_listobj, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_listobj))
        {
            auto txn = listobj();
            lambda(Fields::Field_listobj, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto listobj()
    {
        return Stencil::CreateTransaction<Transaction_listobj>(_elemState.listobj, _txnStateForElem.listobj, *this, _elem.listobj);
    }

    void set_listobj(std::vector<::Objects::ListObject>&& val)
    {
        auto subtxn = listobj();
        subtxn.Assign(std::forward<std::vector<::Objects::ListObject>>(val));
    }

    void add_listobj(::Objects::ListObject&& args)
    {
        _MarkFieldEdited(Fields::Field_listobj);
        auto txn = listobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_listobj(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listobj);
        auto txn = listobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_listobj(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listobj);
        auto txn = listobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_listobj:
        {
            auto txn = listobj();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = listobj();
            lambda(Traits::Field_listobjT{}, txn, Elem().listobj);
        }
    }
};

template <> struct Stencil::Visitor<Objects::List> : Stencil::VisitorT<Objects::List>
{
    using TData  = Objects::List;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_listobj: return lambda(obj.listobj);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_listobjT{}, obj.listobj);
    }
};

template <> struct Stencil::Comparator<Objects::List, Objects::List>
{
    using ThisType = Objects::List;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.listobj, obj2.listobj)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::List> :
    public Stencil::Database::Record<::Stencil::TimestampedT<::Objects::List>>,
    public Stencil::Database::RecordT<Objects::List>
{
    public:
    Stencil::Database::RecordNest<std::vector<::Objects::ListObject>>::Type listobj{};
};

template <> struct Stencil::Database::RecordTraits<Objects::List>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<std::vector<::Objects::ListObject>>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::TimestampedT<::Objects::List>>::RecordTypes,
        std::tuple<Objects::List>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::List>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::List const&                      obj,
                              Stencil::Database::Record<Objects::List>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::TimestampedT<::Objects::List> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::TimestampedT<::Objects::List>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.listobj, rec.listobj);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::List>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::List>>
{
    using TData  = Objects::List;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_listobj: return lambda(obj.listobj);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_listobjT{}, obj.listobj);
    }
};

template <> struct Stencil::TypeTraits<Objects::SimpleObject2>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>
{
    enum class Fields
    {
        Invalid,
        Field_val1
,        Field_val2
,        Field_val3
,        Field_val4
,        Field_val5
,        Field_val6
,        Field_val7
,        Field_val8
    };

    struct Field_val1T
    {};
    struct Field_val2T
    {};
    struct Field_val3T
    {};
    struct Field_val4T
    {};
    struct Field_val5T
    {};
    struct Field_val6T
    {};
    struct Field_val7T
    {};
    struct Field_val8T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val2T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val2T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val2"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val2";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val2T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val2T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val2);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val2) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val3T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val3T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val3"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val3";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val3T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val3T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val3);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val3) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val4T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val4T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val4"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val4";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val4T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val4T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val4);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val4) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val5T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val5T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val5"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val5";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val5T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val5T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val5);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val5) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val6T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val6T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val6"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val6";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val6T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val6T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val6);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val6) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val7T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val7T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val7"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val7";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val7T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val7T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val7);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val7) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val8T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val8T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "val8"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "val8";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val8T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Field_val8T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_val8);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_val8) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "val1"
,        "val2"
,        "val3"
,        "val4"
,        "val5"
,        "val6"
,        "val7"
,        "val8"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::SimpleObject2, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::SimpleObject2>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState val1 = {Fields::Field_val1};
        ElemTxnState val2 = {Fields::Field_val2};
        ElemTxnState val3 = {Fields::Field_val3};
        ElemTxnState val4 = {Fields::Field_val4};
        ElemTxnState val5 = {Fields::Field_val5};
        ElemTxnState val6 = {Fields::Field_val6};
        ElemTxnState val7 = {Fields::Field_val7};
        ElemTxnState val8 = {Fields::Field_val8};
    };

    using Txn               = Stencil::Transaction<Objects::SimpleObject2, TContainer>;
    using ElemType          = Objects::SimpleObject2;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_val1 = Stencil::Transaction<bool, Txn>;
    using Transaction_val2 = Stencil::Transaction<double, Txn>;
    using Transaction_val3 = Stencil::Transaction<std::array<char, 8>, Txn>;
    using Transaction_val4 = Stencil::Transaction<Stencil::Timestamp, Txn>;
    using Transaction_val5 = Stencil::Transaction<uint64_t, Txn>;
    using Transaction_val6 = Stencil::Transaction<int64_t, Txn>;
    using Transaction_val7 = Stencil::Transaction<uint16_t, Txn>;
    using Transaction_val8 = Stencil::Transaction<int16_t, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_val1::TxnState val1{};
        typename Transaction_val2::TxnState val2{};
        typename Transaction_val3::TxnState val3{};
        typename Transaction_val4::TxnState val4{};
        typename Transaction_val5::TxnState val5{};
        typename Transaction_val6::TxnState val6{};
        typename Transaction_val7::TxnState val7{};
        typename Transaction_val8::TxnState val8{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_val1))
        {
            auto txn = val1();
            lambda(Fields::Field_val1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val1))
        {
            auto txn = val1();
            lambda(Fields::Field_val1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val2))
        {
            auto txn = val2();
            lambda(Fields::Field_val2, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val2))
        {
            auto txn = val2();
            lambda(Fields::Field_val2, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val3))
        {
            auto txn = val3();
            lambda(Fields::Field_val3, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val3))
        {
            auto txn = val3();
            lambda(Fields::Field_val3, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val4))
        {
            auto txn = val4();
            lambda(Fields::Field_val4, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val4))
        {
            auto txn = val4();
            lambda(Fields::Field_val4, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val5))
        {
            auto txn = val5();
            lambda(Fields::Field_val5, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val5))
        {
            auto txn = val5();
            lambda(Fields::Field_val5, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val6))
        {
            auto txn = val6();
            lambda(Fields::Field_val6, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val6))
        {
            auto txn = val6();
            lambda(Fields::Field_val6, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val7))
        {
            auto txn = val7();
            lambda(Fields::Field_val7, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val7))
        {
            auto txn = val7();
            lambda(Fields::Field_val7, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_val8))
        {
            auto txn = val8();
            lambda(Fields::Field_val8, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_val8))
        {
            auto txn = val8();
            lambda(Fields::Field_val8, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto val1()
    {
        return Stencil::CreateTransaction<Transaction_val1>(_elemState.val1, _txnStateForElem.val1, *this, _elem.val1);
    }

    auto val2()
    {
        return Stencil::CreateTransaction<Transaction_val2>(_elemState.val2, _txnStateForElem.val2, *this, _elem.val2);
    }

    auto val3()
    {
        return Stencil::CreateTransaction<Transaction_val3>(_elemState.val3, _txnStateForElem.val3, *this, _elem.val3);
    }

    auto val4()
    {
        return Stencil::CreateTransaction<Transaction_val4>(_elemState.val4, _txnStateForElem.val4, *this, _elem.val4);
    }

    auto val5()
    {
        return Stencil::CreateTransaction<Transaction_val5>(_elemState.val5, _txnStateForElem.val5, *this, _elem.val5);
    }

    auto val6()
    {
        return Stencil::CreateTransaction<Transaction_val6>(_elemState.val6, _txnStateForElem.val6, *this, _elem.val6);
    }

    auto val7()
    {
        return Stencil::CreateTransaction<Transaction_val7>(_elemState.val7, _txnStateForElem.val7, *this, _elem.val7);
    }

    auto val8()
    {
        return Stencil::CreateTransaction<Transaction_val8>(_elemState.val8, _txnStateForElem.val8, *this, _elem.val8);
    }

    void set_val1(bool&& val)
    {
        auto subtxn = val1();
        subtxn.Assign(std::forward<bool>(val));
    }

    void set_val2(double&& val)
    {
        auto subtxn = val2();
        subtxn.Assign(std::forward<double>(val));
    }

    void set_val3(std::array<char, 8>&& val)
    {
        auto subtxn = val3();
        subtxn.Assign(std::forward<std::array<char, 8>>(val));
    }

    void set_val4(Stencil::Timestamp&& val)
    {
        auto subtxn = val4();
        subtxn.Assign(std::forward<Stencil::Timestamp>(val));
    }

    void set_val5(uint64_t&& val)
    {
        auto subtxn = val5();
        subtxn.Assign(std::forward<uint64_t>(val));
    }

    void set_val6(int64_t&& val)
    {
        auto subtxn = val6();
        subtxn.Assign(std::forward<int64_t>(val));
    }

    void set_val7(uint16_t&& val)
    {
        auto subtxn = val7();
        subtxn.Assign(std::forward<uint16_t>(val));
    }

    void set_val8(int16_t&& val)
    {
        auto subtxn = val8();
        subtxn.Assign(std::forward<int16_t>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_val1:
        {
            auto txn = val1();
            return lambda(txn);
        }
        case Fields::Field_val2:
        {
            auto txn = val2();
            return lambda(txn);
        }
        case Fields::Field_val3:
        {
            auto txn = val3();
            return lambda(txn);
        }
        case Fields::Field_val4:
        {
            auto txn = val4();
            return lambda(txn);
        }
        case Fields::Field_val5:
        {
            auto txn = val5();
            return lambda(txn);
        }
        case Fields::Field_val6:
        {
            auto txn = val6();
            return lambda(txn);
        }
        case Fields::Field_val7:
        {
            auto txn = val7();
            return lambda(txn);
        }
        case Fields::Field_val8:
        {
            auto txn = val8();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = val1();
            lambda(Traits::Field_val1T{}, txn, Elem().val1);
        }
        {
            auto txn = val2();
            lambda(Traits::Field_val2T{}, txn, Elem().val2);
        }
        {
            auto txn = val3();
            lambda(Traits::Field_val3T{}, txn, Elem().val3);
        }
        {
            auto txn = val4();
            lambda(Traits::Field_val4T{}, txn, Elem().val4);
        }
        {
            auto txn = val5();
            lambda(Traits::Field_val5T{}, txn, Elem().val5);
        }
        {
            auto txn = val6();
            lambda(Traits::Field_val6T{}, txn, Elem().val6);
        }
        {
            auto txn = val7();
            lambda(Traits::Field_val7T{}, txn, Elem().val7);
        }
        {
            auto txn = val8();
            lambda(Traits::Field_val8T{}, txn, Elem().val8);
        }
    }
};

template <> struct Stencil::Visitor<Objects::SimpleObject2> : Stencil::VisitorT<Objects::SimpleObject2>
{
    using TData  = Objects::SimpleObject2;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_val1: return lambda(obj.val1);
        case Fields::Field_val2: return lambda(obj.val2);
        case Fields::Field_val3: return lambda(obj.val3);
        case Fields::Field_val4: return lambda(obj.val4);
        case Fields::Field_val5: return lambda(obj.val5);
        case Fields::Field_val6: return lambda(obj.val6);
        case Fields::Field_val7: return lambda(obj.val7);
        case Fields::Field_val8: return lambda(obj.val8);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_val1T{}, obj.val1);
        lambda(Traits::Field_val2T{}, obj.val2);
        lambda(Traits::Field_val3T{}, obj.val3);
        lambda(Traits::Field_val4T{}, obj.val4);
        lambda(Traits::Field_val5T{}, obj.val5);
        lambda(Traits::Field_val6T{}, obj.val6);
        lambda(Traits::Field_val7T{}, obj.val7);
        lambda(Traits::Field_val8T{}, obj.val8);
    }
};

template <> struct Stencil::Comparator<Objects::SimpleObject2, Objects::SimpleObject2>
{
    using ThisType = Objects::SimpleObject2;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.val1, obj2.val1)
               && Stencil::AreEqual(obj1.val2, obj2.val2)
               && Stencil::AreEqual(obj1.val3, obj2.val3)
               && Stencil::AreEqual(obj1.val4, obj2.val4)
               && Stencil::AreEqual(obj1.val5, obj2.val5)
               && Stencil::AreEqual(obj1.val6, obj2.val6)
               && Stencil::AreEqual(obj1.val7, obj2.val7)
               && Stencil::AreEqual(obj1.val8, obj2.val8)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::SimpleObject2> :
    public Stencil::Database::Record<::Stencil::OptionalPropsT<::Objects::SimpleObject2>>,
    public Stencil::Database::Record<::Stencil::TimestampedT<::Objects::SimpleObject2>>,
    public Stencil::Database::RecordT<Objects::SimpleObject2>
{
    public:
    Stencil::Database::RecordNest<bool>::Type val1{};
    Stencil::Database::RecordNest<double>::Type val2{};
    Stencil::Database::RecordNest<std::array<char, 8>>::Type val3{};
    Stencil::Database::RecordNest<Stencil::Timestamp>::Type val4{};
    Stencil::Database::RecordNest<uint64_t>::Type val5{};
    Stencil::Database::RecordNest<int64_t>::Type val6{};
    Stencil::Database::RecordNest<uint16_t>::Type val7{};
    Stencil::Database::RecordNest<int16_t>::Type val8{};
};

template <> struct Stencil::Database::RecordTraits<Objects::SimpleObject2>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<bool>::RecordTypes,
        typename Stencil::Database::RecordTraits<double>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::array<char, 8>>::RecordTypes,
        typename Stencil::Database::RecordTraits<Stencil::Timestamp>::RecordTypes,
        typename Stencil::Database::RecordTraits<uint64_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<int64_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<uint16_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<int16_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::OptionalPropsT<::Objects::SimpleObject2>>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::TimestampedT<::Objects::SimpleObject2>>::RecordTypes,
        std::tuple<Objects::SimpleObject2>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::SimpleObject2>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::SimpleObject2 const&                      obj,
                              Stencil::Database::Record<Objects::SimpleObject2>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::OptionalPropsT<::Objects::SimpleObject2> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::OptionalPropsT<::Objects::SimpleObject2>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::TimestampedT<::Objects::SimpleObject2> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::TimestampedT<::Objects::SimpleObject2>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val1, rec.val1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val2, rec.val2);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val3, rec.val3);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val4, rec.val4);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val5, rec.val5);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val6, rec.val6);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val7, rec.val7);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.val8, rec.val8);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::SimpleObject2>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::SimpleObject2>>
{
    using TData  = Objects::SimpleObject2;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_val1: return lambda(obj.val1);
        case Fields::Field_val2: return lambda(obj.val2);
        case Fields::Field_val3: return lambda(obj.val3);
        case Fields::Field_val4: return lambda(obj.val4);
        case Fields::Field_val5: return lambda(obj.val5);
        case Fields::Field_val6: return lambda(obj.val6);
        case Fields::Field_val7: return lambda(obj.val7);
        case Fields::Field_val8: return lambda(obj.val8);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_val1T{}, obj.val1);
        lambda(Traits::Field_val2T{}, obj.val2);
        lambda(Traits::Field_val3T{}, obj.val3);
        lambda(Traits::Field_val4T{}, obj.val4);
        lambda(Traits::Field_val5T{}, obj.val5);
        lambda(Traits::Field_val6T{}, obj.val6);
        lambda(Traits::Field_val7T{}, obj.val7);
        lambda(Traits::Field_val8T{}, obj.val8);
    }
};

template <> struct Stencil::TypeTraits<Objects::NestedObject>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::NestedObject>
{
    enum class Fields
    {
        Invalid,
        Field_obj1
,        Field_obj2
,        Field_obj3
,        Field_dict1
,        Field_list1
    };

    struct Field_obj1T
    {};
    struct Field_obj2T
    {};
    struct Field_obj3T
    {};
    struct Field_dict1T
    {};
    struct Field_list1T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "obj1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "obj1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_obj1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_obj1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj2T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj2T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "obj2"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "obj2";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj2T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj2T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_obj2);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_obj2) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj3T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj3T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "obj3"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "obj3";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj3T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_obj3T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_obj3);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_obj3) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_dict1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_dict1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "dict1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "dict1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_dict1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_dict1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_dict1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_dict1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_list1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_list1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "list1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "list1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_list1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Field_list1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_list1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_list1) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "obj1"
,        "obj2"
,        "obj3"
,        "dict1"
,        "list1"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::NestedObject>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::NestedObject, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::NestedObject>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState obj1 = {Fields::Field_obj1};
        ElemTxnState obj2 = {Fields::Field_obj2};
        ElemTxnState obj3 = {Fields::Field_obj3};
        ElemTxnState dict1 = {Fields::Field_dict1};
        ElemTxnState list1 = {Fields::Field_list1};
    };

    using Txn               = Stencil::Transaction<Objects::NestedObject, TContainer>;
    using ElemType          = Objects::NestedObject;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_obj1 = Stencil::Transaction<::Objects::SimpleObject1, Txn>;
    using Transaction_obj2 = Stencil::Transaction<::Objects::SimpleObject2, Txn>;
    using Transaction_obj3 = Stencil::Transaction<::Objects::ListObject, Txn>;
    using Transaction_dict1 = Stencil::Transaction<::Objects::DictObject, Txn>;
    using Transaction_list1 = Stencil::Transaction<::Objects::List, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_obj1::TxnState obj1{};
        typename Transaction_obj2::TxnState obj2{};
        typename Transaction_obj3::TxnState obj3{};
        typename Transaction_dict1::TxnState dict1{};
        typename Transaction_list1::TxnState list1{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_obj2))
        {
            auto txn = obj2();
            lambda(Fields::Field_obj2, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_obj2))
        {
            auto txn = obj2();
            lambda(Fields::Field_obj2, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_obj3))
        {
            auto txn = obj3();
            lambda(Fields::Field_obj3, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_obj3))
        {
            auto txn = obj3();
            lambda(Fields::Field_obj3, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_dict1))
        {
            auto txn = dict1();
            lambda(Fields::Field_dict1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_dict1))
        {
            auto txn = dict1();
            lambda(Fields::Field_dict1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_list1))
        {
            auto txn = list1();
            lambda(Fields::Field_list1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_list1))
        {
            auto txn = list1();
            lambda(Fields::Field_list1, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto obj1()
    {
        return Stencil::CreateTransaction<Transaction_obj1>(_elemState.obj1, _txnStateForElem.obj1, *this, _elem.obj1);
    }

    auto obj2()
    {
        return Stencil::CreateTransaction<Transaction_obj2>(_elemState.obj2, _txnStateForElem.obj2, *this, _elem.obj2);
    }

    auto obj3()
    {
        return Stencil::CreateTransaction<Transaction_obj3>(_elemState.obj3, _txnStateForElem.obj3, *this, _elem.obj3);
    }

    auto dict1()
    {
        return Stencil::CreateTransaction<Transaction_dict1>(_elemState.dict1, _txnStateForElem.dict1, *this, _elem.dict1);
    }

    auto list1()
    {
        return Stencil::CreateTransaction<Transaction_list1>(_elemState.list1, _txnStateForElem.list1, *this, _elem.list1);
    }

    void set_obj1(::Objects::SimpleObject1&& val)
    {
        auto subtxn = obj1();
        subtxn.Assign(std::forward<::Objects::SimpleObject1>(val));
    }

    void set_obj2(::Objects::SimpleObject2&& val)
    {
        auto subtxn = obj2();
        subtxn.Assign(std::forward<::Objects::SimpleObject2>(val));
    }

    void set_obj3(::Objects::ListObject&& val)
    {
        auto subtxn = obj3();
        subtxn.Assign(std::forward<::Objects::ListObject>(val));
    }

    void set_dict1(::Objects::DictObject&& val)
    {
        auto subtxn = dict1();
        subtxn.Assign(std::forward<::Objects::DictObject>(val));
    }

    void set_list1(::Objects::List&& val)
    {
        auto subtxn = list1();
        subtxn.Assign(std::forward<::Objects::List>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_obj1:
        {
            auto txn = obj1();
            return lambda(txn);
        }
        case Fields::Field_obj2:
        {
            auto txn = obj2();
            return lambda(txn);
        }
        case Fields::Field_obj3:
        {
            auto txn = obj3();
            return lambda(txn);
        }
        case Fields::Field_dict1:
        {
            auto txn = dict1();
            return lambda(txn);
        }
        case Fields::Field_list1:
        {
            auto txn = list1();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = obj1();
            lambda(Traits::Field_obj1T{}, txn, Elem().obj1);
        }
        {
            auto txn = obj2();
            lambda(Traits::Field_obj2T{}, txn, Elem().obj2);
        }
        {
            auto txn = obj3();
            lambda(Traits::Field_obj3T{}, txn, Elem().obj3);
        }
        {
            auto txn = dict1();
            lambda(Traits::Field_dict1T{}, txn, Elem().dict1);
        }
        {
            auto txn = list1();
            lambda(Traits::Field_list1T{}, txn, Elem().list1);
        }
    }
};

template <> struct Stencil::Visitor<Objects::NestedObject> : Stencil::VisitorT<Objects::NestedObject>
{
    using TData  = Objects::NestedObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Field_obj2: return lambda(obj.obj2);
        case Fields::Field_obj3: return lambda(obj.obj3);
        case Fields::Field_dict1: return lambda(obj.dict1);
        case Fields::Field_list1: return lambda(obj.list1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_obj1T{}, obj.obj1);
        lambda(Traits::Field_obj2T{}, obj.obj2);
        lambda(Traits::Field_obj3T{}, obj.obj3);
        lambda(Traits::Field_dict1T{}, obj.dict1);
        lambda(Traits::Field_list1T{}, obj.list1);
    }
};

template <> struct Stencil::Comparator<Objects::NestedObject, Objects::NestedObject>
{
    using ThisType = Objects::NestedObject;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.obj1, obj2.obj1)
               && Stencil::AreEqual(obj1.obj2, obj2.obj2)
               && Stencil::AreEqual(obj1.obj3, obj2.obj3)
               && Stencil::AreEqual(obj1.dict1, obj2.dict1)
               && Stencil::AreEqual(obj1.list1, obj2.list1)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::NestedObject> :
    public Stencil::Database::Record<::Stencil::TimestampedT<::Objects::NestedObject>>,
    public Stencil::Database::RecordT<Objects::NestedObject>
{
    public:
    Stencil::Database::RecordNest<::Objects::SimpleObject1>::Type obj1{};
    Stencil::Database::RecordNest<::Objects::SimpleObject2>::Type obj2{};
    Stencil::Database::RecordNest<::Objects::ListObject>::Type obj3{};
    Stencil::Database::RecordNest<::Objects::DictObject>::Type dict1{};
    Stencil::Database::RecordNest<::Objects::List>::Type list1{};
};

template <> struct Stencil::Database::RecordTraits<Objects::NestedObject>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<::Objects::SimpleObject1>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Objects::SimpleObject2>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Objects::ListObject>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Objects::DictObject>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Objects::List>::RecordTypes,
        typename Stencil::Database::RecordTraits<::Stencil::TimestampedT<::Objects::NestedObject>>::RecordTypes,
        std::tuple<Objects::NestedObject>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::NestedObject>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::NestedObject const&                      obj,
                              Stencil::Database::Record<Objects::NestedObject>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db,
                                               lock,
                                               static_cast<::Stencil::TimestampedT<::Objects::NestedObject> const&>(obj),
                                               static_cast<Stencil::Database::Record<::Stencil::TimestampedT<::Objects::NestedObject>>&>(rec));
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.obj1, rec.obj1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.obj2, rec.obj2);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.obj3, rec.obj3);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.dict1, rec.dict1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.list1, rec.list1);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::NestedObject>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::NestedObject>>
{
    using TData  = Objects::NestedObject;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Field_obj2: return lambda(obj.obj2);
        case Fields::Field_obj3: return lambda(obj.obj3);
        case Fields::Field_dict1: return lambda(obj.dict1);
        case Fields::Field_list1: return lambda(obj.list1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_obj1T{}, obj.obj1);
        lambda(Traits::Field_obj2T{}, obj.obj2);
        lambda(Traits::Field_obj3T{}, obj.obj3);
        lambda(Traits::Field_dict1T{}, obj.dict1);
        lambda(Traits::Field_list1T{}, obj.list1);
    }
};

template <> struct Stencil::TypeTraits<Objects::SelfNested>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<Objects::SelfNested>
{
    enum class Fields
    {
        Invalid,
        Field_obj1
,        Field_self
    };

    struct Field_obj1T
    {};
    struct Field_selfT
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_obj1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_obj1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "obj1"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "obj1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_obj1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_obj1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_obj1);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_obj1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_selfT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_selfT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "self"); }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        std::string_view name = "self";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_selfT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Field_selfT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_self);
    }

    template <typename Context> static auto Read(T& /* obj */, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_self) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "obj1"
,        "self"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<Objects::SelfNested>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<Objects::SelfNested, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<Objects::SelfNested>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState obj1 = {Fields::Field_obj1};
        ElemTxnState self = {Fields::Field_self};
    };

    using Txn               = Stencil::Transaction<Objects::SelfNested, TContainer>;
    using ElemType          = Objects::SelfNested;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_obj1 = Stencil::Transaction<::Objects::SimpleObject1, Txn>;
    using Transaction_self = Stencil::Transaction<Stencil::Ref<::Objects::SelfNested>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_obj1::TxnState obj1{};
        typename Transaction_self::TxnState self{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_obj1))
        {
            auto txn = obj1();
            lambda(Fields::Field_obj1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_self))
        {
            auto txn = self();
            lambda(Fields::Field_self, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_self))
        {
            auto txn = self();
            lambda(Fields::Field_self, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto obj1()
    {
        return Stencil::CreateTransaction<Transaction_obj1>(_elemState.obj1, _txnStateForElem.obj1, *this, _elem.obj1);
    }

    auto self()
    {
        return Stencil::CreateTransaction<Transaction_self>(_elemState.self, _txnStateForElem.self, *this, _elem.self);
    }

    void set_obj1(::Objects::SimpleObject1&& val)
    {
        auto subtxn = obj1();
        subtxn.Assign(std::forward<::Objects::SimpleObject1>(val));
    }

    void set_self(Stencil::Ref<::Objects::SelfNested>&& val)
    {
        auto subtxn = self();
        subtxn.Assign(std::forward<Stencil::Ref<::Objects::SelfNested>>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_obj1:
        {
            auto txn = obj1();
            return lambda(txn);
        }
        case Fields::Field_self:
        {
            auto txn = self();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = obj1();
            lambda(Traits::Field_obj1T{}, txn, Elem().obj1);
        }
        {
            auto txn = self();
            lambda(Traits::Field_selfT{}, txn, Elem().self);
        }
    }
};

template <> struct Stencil::Visitor<Objects::SelfNested> : Stencil::VisitorT<Objects::SelfNested>
{
    using TData  = Objects::SelfNested;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Field_self: return lambda(obj.self);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_obj1T{}, obj.obj1);
        lambda(Traits::Field_selfT{}, obj.self);
    }
};

template <> struct Stencil::Comparator<Objects::SelfNested, Objects::SelfNested>
{
    using ThisType = Objects::SelfNested;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.obj1, obj2.obj1)
               && Stencil::AreEqual(obj1.self, obj2.self)
            ;
    }
};

template <>
struct Stencil::Database::Record<Objects::SelfNested> :
    public Stencil::Database::RecordT<Objects::SelfNested>
{
    public:
    Stencil::Database::RecordNest<::Objects::SimpleObject1>::Type obj1{};
    Stencil::Database::RecordNest<Stencil::Ref<::Objects::SelfNested>>::Type self{};
};

template <> struct Stencil::Database::RecordTraits<Objects::SelfNested>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<::Objects::SimpleObject1>::RecordTypes,
        typename Stencil::Database::RecordTraits<Stencil::Ref<::Objects::SelfNested>>::RecordTypes,
        std::tuple<Objects::SelfNested>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<Objects::SelfNested>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              Objects::SelfNested const&                      obj,
                              Stencil::Database::Record<Objects::SelfNested>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.obj1, rec.obj1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.self, rec.self);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<Objects::SelfNested>>
    : Stencil::VisitorT<Stencil::Database::Record<Objects::SelfNested>>
{
    using TData  = Objects::SelfNested;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_obj1: return lambda(obj.obj1);
        case Fields::Field_self: return lambda(obj.self);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_obj1T{}, obj.obj1);
        lambda(Traits::Field_selfT{}, obj.self);
    }
};

#endif
// SECTION END: Template specializations

// SECTION START: Inline Function Definitions
#if true

#endif
// SECTION END: Inline Function Definitions
