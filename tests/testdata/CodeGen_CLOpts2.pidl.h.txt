#pragma once
#include <stencil/stencil.h>
// SECTION START: DECLARATIONS
#if true

namespace CLOpts2
{
struct InstallOptions;
struct QueueOptions;
struct PauseOptions;
struct CancelOptions;
struct ResumeOptions;
struct UpdateOptions;
struct HydrateOptions;
struct CommandLineOptions;
}    // namespace CLOpts2

template <> struct Stencil::TypeTraits<CLOpts2::InstallOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::QueueOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::PauseOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::CancelOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::ResumeOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::UpdateOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::HydrateOptions>;
template <> struct Stencil::TypeTraits<CLOpts2::CommandLineOptions>;
#endif
// SECTION END: DECLARATIONS

// SECTION START: Definitions
#if true
namespace CLOpts2
{
struct InstallOptions :
    public Stencil::StructT<InstallOptions>
{
    shared_string ProductId = {};
    bool Repair = 0;
    bool ForceNonSD = 0;
    shared_string TargetVolume = {};
    shared_string User = {};
};
struct QueueOptions :
    public Stencil::StructT<QueueOptions>
{
    shared_string ProductId = {};
};
struct PauseOptions :
    public Stencil::StructT<PauseOptions>
{
    shared_string ProductId = {};
};
struct CancelOptions :
    public Stencil::StructT<CancelOptions>
{
    shared_string ProductId = {};
};
struct ResumeOptions :
    public Stencil::StructT<ResumeOptions>
{
    shared_string ProductId = {};
};
struct UpdateOptions :
    public Stencil::StructT<UpdateOptions>
{
    shared_string ProductId = {};
};
struct HydrateOptions :
    public Stencil::StructT<HydrateOptions>
{
    shared_string ProductId = {};
};
struct CommandLineOptions : public Stencil::VariantT<CommandLineOptions>
{
    std::variant<std::monostate,
                 ::CLOpts2::InstallOptions
,                 ::CLOpts2::QueueOptions
,                 ::CLOpts2::PauseOptions
,                 ::CLOpts2::CancelOptions
,                 ::CLOpts2::ResumeOptions
,                 ::CLOpts2::UpdateOptions
,                 ::CLOpts2::HydrateOptions
                 >
        _variant;

    enum class VariantType
    {
        Invalid,
        install
,        queue
,        pause
,        cancel
,        resume
,        update
,        hydrate
    };

    VariantType Type() const { return static_cast<VariantType>(_variant.index()); }

    ::CLOpts2::InstallOptions&       install() { return std::get<::CLOpts2::InstallOptions>(_variant); }
    ::CLOpts2::InstallOptions const& install() const { return std::get<::CLOpts2::InstallOptions>(_variant); }
    ::CLOpts2::QueueOptions&       queue() { return std::get<::CLOpts2::QueueOptions>(_variant); }
    ::CLOpts2::QueueOptions const& queue() const { return std::get<::CLOpts2::QueueOptions>(_variant); }
    ::CLOpts2::PauseOptions&       pause() { return std::get<::CLOpts2::PauseOptions>(_variant); }
    ::CLOpts2::PauseOptions const& pause() const { return std::get<::CLOpts2::PauseOptions>(_variant); }
    ::CLOpts2::CancelOptions&       cancel() { return std::get<::CLOpts2::CancelOptions>(_variant); }
    ::CLOpts2::CancelOptions const& cancel() const { return std::get<::CLOpts2::CancelOptions>(_variant); }
    ::CLOpts2::ResumeOptions&       resume() { return std::get<::CLOpts2::ResumeOptions>(_variant); }
    ::CLOpts2::ResumeOptions const& resume() const { return std::get<::CLOpts2::ResumeOptions>(_variant); }
    ::CLOpts2::UpdateOptions&       update() { return std::get<::CLOpts2::UpdateOptions>(_variant); }
    ::CLOpts2::UpdateOptions const& update() const { return std::get<::CLOpts2::UpdateOptions>(_variant); }
    ::CLOpts2::HydrateOptions&       hydrate() { return std::get<::CLOpts2::HydrateOptions>(_variant); }
    ::CLOpts2::HydrateOptions const& hydrate() const { return std::get<::CLOpts2::HydrateOptions>(_variant); }
};
}    // namespace CLOpts2
#endif

// SECTION END: Definitions

// SECTION START: Template specializations
#if true

// SECTION:

template <> struct Stencil::TypeTraits<CLOpts2::InstallOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
,        Field_Repair
,        Field_ForceNonSD
,        Field_TargetVolume
,        Field_User
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
,        "Repair"
,        "ForceNonSD"
,        "TargetVolume"
,        "User"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::InstallOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
        ElemTxnState Repair = {Fields::Field_Repair};
        ElemTxnState ForceNonSD = {Fields::Field_ForceNonSD};
        ElemTxnState TargetVolume = {Fields::Field_TargetVolume};
        ElemTxnState User = {Fields::Field_User};
    };

    using Txn               = Stencil::Transaction<CLOpts2::InstallOptions, TContainer>;
    using ElemType          = CLOpts2::InstallOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    using Transaction_Repair = Stencil::Transaction<bool, Txn>;
    using Transaction_ForceNonSD = Stencil::Transaction<bool, Txn>;
    using Transaction_TargetVolume = Stencil::Transaction<shared_string, Txn>;
    using Transaction_User = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
        typename Transaction_Repair::TxnState Repair{};
        typename Transaction_ForceNonSD::TxnState ForceNonSD{};
        typename Transaction_TargetVolume::TxnState TargetVolume{};
        typename Transaction_User::TxnState User{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_Repair))
        {
            auto txn = Repair();
            lambda(Fields::Field_Repair, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_Repair))
        {
            auto txn = Repair();
            lambda(Fields::Field_Repair, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_ForceNonSD))
        {
            auto txn = ForceNonSD();
            lambda(Fields::Field_ForceNonSD, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ForceNonSD))
        {
            auto txn = ForceNonSD();
            lambda(Fields::Field_ForceNonSD, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_TargetVolume))
        {
            auto txn = TargetVolume();
            lambda(Fields::Field_TargetVolume, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_TargetVolume))
        {
            auto txn = TargetVolume();
            lambda(Fields::Field_TargetVolume, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_User))
        {
            auto txn = User();
            lambda(Fields::Field_User, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_User))
        {
            auto txn = User();
            lambda(Fields::Field_User, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    auto Repair()
    {
        return Stencil::CreateTransaction<Transaction_Repair>(_elemState.Repair, _txnStateForElem.Repair, *this, _elem.Repair);
    }

    auto ForceNonSD()
    {
        return Stencil::CreateTransaction<Transaction_ForceNonSD>(_elemState.ForceNonSD, _txnStateForElem.ForceNonSD, *this, _elem.ForceNonSD);
    }

    auto TargetVolume()
    {
        return Stencil::CreateTransaction<Transaction_TargetVolume>(_elemState.TargetVolume, _txnStateForElem.TargetVolume, *this, _elem.TargetVolume);
    }

    auto User()
    {
        return Stencil::CreateTransaction<Transaction_User>(_elemState.User, _txnStateForElem.User, *this, _elem.User);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_Repair(bool&& val)
    {
        auto subtxn = Repair();
        subtxn.Assign(std::forward<bool>(val));
    }

    void set_ForceNonSD(bool&& val)
    {
        auto subtxn = ForceNonSD();
        subtxn.Assign(std::forward<bool>(val));
    }

    void set_TargetVolume(shared_string&& val)
    {
        auto subtxn = TargetVolume();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_User(shared_string&& val)
    {
        auto subtxn = User();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Field_Repair:
        {
            auto txn = Repair();
            return lambda(txn);
        }
        case Fields::Field_ForceNonSD:
        {
            auto txn = ForceNonSD();
            return lambda(txn);
        }
        case Fields::Field_TargetVolume:
        {
            auto txn = TargetVolume();
            return lambda(txn);
        }
        case Fields::Field_User:
        {
            auto txn = User();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
        {
            auto txn = Repair();
            lambda(Fields::Field_Repair, txn, Elem().Repair);
        }
        {
            auto txn = ForceNonSD();
            lambda(Fields::Field_ForceNonSD, txn, Elem().ForceNonSD);
        }
        {
            auto txn = TargetVolume();
            lambda(Fields::Field_TargetVolume, txn, Elem().TargetVolume);
        }
        {
            auto txn = User();
            lambda(Fields::Field_User, txn, Elem().User);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::InstallOptions> : Stencil::VisitorT<CLOpts2::InstallOptions>
{
    using TData  = CLOpts2::InstallOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Field_Repair: return lambda(obj.Repair);
        case Fields::Field_ForceNonSD: return lambda(obj.ForceNonSD);
        case Fields::Field_TargetVolume: return lambda(obj.TargetVolume);
        case Fields::Field_User: return lambda(obj.User);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
        lambda(Fields::Field_Repair, obj.Repair);
        lambda(Fields::Field_ForceNonSD, obj.ForceNonSD);
        lambda(Fields::Field_TargetVolume, obj.TargetVolume);
        lambda(Fields::Field_User, obj.User);
    }
};

template <> struct Stencil::Comparator<CLOpts2::InstallOptions, CLOpts2::InstallOptions>
{
    using ThisType = CLOpts2::InstallOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
               && Stencil::AreEqual(obj1.Repair, obj2.Repair)
               && Stencil::AreEqual(obj1.ForceNonSD, obj2.ForceNonSD)
               && Stencil::AreEqual(obj1.TargetVolume, obj2.TargetVolume)
               && Stencil::AreEqual(obj1.User, obj2.User)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::InstallOptions> :
    public Stencil::Database::RecordT<CLOpts2::InstallOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
    Stencil::Database::RecordNest<bool>::Type Repair{};
    Stencil::Database::RecordNest<bool>::Type ForceNonSD{};
    Stencil::Database::RecordNest<shared_string>::Type TargetVolume{};
    Stencil::Database::RecordNest<shared_string>::Type User{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::InstallOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<bool>::RecordTypes,
        typename Stencil::Database::RecordTraits<bool>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::InstallOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::InstallOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::InstallOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::InstallOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.Repair, rec.Repair);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ForceNonSD, rec.ForceNonSD);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.TargetVolume, rec.TargetVolume);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.User, rec.User);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::InstallOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::InstallOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::InstallOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::InstallOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Field_Repair: return lambda(obj.Repair);
        case Fields::Field_ForceNonSD: return lambda(obj.ForceNonSD);
        case Fields::Field_TargetVolume: return lambda(obj.TargetVolume);
        case Fields::Field_User: return lambda(obj.User);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
        lambda(Fields::Field_Repair, obj.Repair);
        lambda(Fields::Field_ForceNonSD, obj.ForceNonSD);
        lambda(Fields::Field_TargetVolume, obj.TargetVolume);
        lambda(Fields::Field_User, obj.User);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::QueueOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::QueueOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::QueueOptions, TContainer>;
    using ElemType          = CLOpts2::QueueOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::QueueOptions> : Stencil::VisitorT<CLOpts2::QueueOptions>
{
    using TData  = CLOpts2::QueueOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::QueueOptions, CLOpts2::QueueOptions>
{
    using ThisType = CLOpts2::QueueOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::QueueOptions> :
    public Stencil::Database::RecordT<CLOpts2::QueueOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::QueueOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::QueueOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::QueueOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::QueueOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::QueueOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::QueueOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::QueueOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::QueueOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::QueueOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::PauseOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::PauseOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::PauseOptions, TContainer>;
    using ElemType          = CLOpts2::PauseOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::PauseOptions> : Stencil::VisitorT<CLOpts2::PauseOptions>
{
    using TData  = CLOpts2::PauseOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::PauseOptions, CLOpts2::PauseOptions>
{
    using ThisType = CLOpts2::PauseOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::PauseOptions> :
    public Stencil::Database::RecordT<CLOpts2::PauseOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::PauseOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::PauseOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::PauseOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::PauseOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::PauseOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::PauseOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::PauseOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::PauseOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::PauseOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::CancelOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::CancelOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::CancelOptions, TContainer>;
    using ElemType          = CLOpts2::CancelOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::CancelOptions> : Stencil::VisitorT<CLOpts2::CancelOptions>
{
    using TData  = CLOpts2::CancelOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::CancelOptions, CLOpts2::CancelOptions>
{
    using ThisType = CLOpts2::CancelOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::CancelOptions> :
    public Stencil::Database::RecordT<CLOpts2::CancelOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::CancelOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::CancelOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::CancelOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::CancelOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::CancelOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::CancelOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::CancelOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::CancelOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::CancelOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::ResumeOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::ResumeOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::ResumeOptions, TContainer>;
    using ElemType          = CLOpts2::ResumeOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::ResumeOptions> : Stencil::VisitorT<CLOpts2::ResumeOptions>
{
    using TData  = CLOpts2::ResumeOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::ResumeOptions, CLOpts2::ResumeOptions>
{
    using ThisType = CLOpts2::ResumeOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::ResumeOptions> :
    public Stencil::Database::RecordT<CLOpts2::ResumeOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::ResumeOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::ResumeOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::ResumeOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::ResumeOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::ResumeOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::ResumeOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::ResumeOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::ResumeOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::ResumeOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::UpdateOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::UpdateOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::UpdateOptions, TContainer>;
    using ElemType          = CLOpts2::UpdateOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::UpdateOptions> : Stencil::VisitorT<CLOpts2::UpdateOptions>
{
    using TData  = CLOpts2::UpdateOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::UpdateOptions, CLOpts2::UpdateOptions>
{
    using ThisType = CLOpts2::UpdateOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::UpdateOptions> :
    public Stencil::Database::RecordT<CLOpts2::UpdateOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::UpdateOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::UpdateOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::UpdateOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::UpdateOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::UpdateOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::UpdateOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::UpdateOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::UpdateOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::UpdateOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::HydrateOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>
{
    enum class Fields
    {
        Invalid,
        Field_ProductId
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "ProductId"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts2::HydrateOptions, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState ProductId = {Fields::Field_ProductId};
    };

    using Txn               = Stencil::Transaction<CLOpts2::HydrateOptions, TContainer>;
    using ElemType          = CLOpts2::HydrateOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_ProductId = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_ProductId::TxnState ProductId{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_ProductId))
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto ProductId()
    {
        return Stencil::CreateTransaction<Transaction_ProductId>(_elemState.ProductId, _txnStateForElem.ProductId, *this, _elem.ProductId);
    }

    void set_ProductId(shared_string&& val)
    {
        auto subtxn = ProductId();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_ProductId:
        {
            auto txn = ProductId();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = ProductId();
            lambda(Fields::Field_ProductId, txn, Elem().ProductId);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts2::HydrateOptions> : Stencil::VisitorT<CLOpts2::HydrateOptions>
{
    using TData  = CLOpts2::HydrateOptions;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::Comparator<CLOpts2::HydrateOptions, CLOpts2::HydrateOptions>
{
    using ThisType = CLOpts2::HydrateOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.ProductId, obj2.ProductId)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts2::HydrateOptions> :
    public Stencil::Database::RecordT<CLOpts2::HydrateOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type ProductId{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts2::HydrateOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts2::HydrateOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts2::HydrateOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts2::HydrateOptions const&                      obj,
                              Stencil::Database::Record<CLOpts2::HydrateOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.ProductId, rec.ProductId);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts2::HydrateOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts2::HydrateOptions>>
{
    using TData  = Stencil::Database::Record<CLOpts2::HydrateOptions>;
    using Fields = TypeTraitsForIndexable<CLOpts2::HydrateOptions>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_ProductId: return lambda(obj.ProductId);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_ProductId, obj.ProductId);
    }
};

template <> struct Stencil::TypeTraits<CLOpts2::CommandLineOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts2::CommandLineOptions>
{
    using Key    = CLOpts2::CommandLineOptions::VariantType;
    using Fields = Key;
};

template <> struct Stencil::EnumTraits<CLOpts2::CommandLineOptions::VariantType>
{
    using Enum = CLOpts2::CommandLineOptions::VariantType;
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
    static constexpr std::string_view Names[] = {
        "Invalid",
        "install"
,        "queue"
,        "pause"
,        "cancel"
,        "resume"
,        "update"
,        "hydrate"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
#pragma clang diagnostic pop

    static CLOpts2::CommandLineOptions::VariantType ForIndex(size_t index)
    {
        return static_cast<CLOpts2::CommandLineOptions::VariantType>(index);
    }
};

template <> struct Stencil::Visitor<CLOpts2::CommandLineOptions>
{
    using Fields = CLOpts2::CommandLineOptions::VariantType;

    template <typename TType, typename TObj, typename TLambda> static void _SetAndVisit(TObj& obj, TLambda&& lambda)
    {
        using Type = std::remove_cvref_t<TType>;
        obj        = Type{};
        lambda(std::get<Type>(obj));
    }

    template <typename T, typename TLambda> static void VisitKey(T& obj, Fields fields, TLambda&& lambda)
    {
        switch (fields)
        {
        case Fields::install:
            _SetAndVisit<::CLOpts2::InstallOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::queue:
            _SetAndVisit<::CLOpts2::QueueOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::pause:
            _SetAndVisit<::CLOpts2::PauseOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::cancel:
            _SetAndVisit<::CLOpts2::CancelOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::resume:
            _SetAndVisit<::CLOpts2::ResumeOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::update:
            _SetAndVisit<::CLOpts2::UpdateOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::hydrate:
            _SetAndVisit<::CLOpts2::HydrateOptions>(obj._variant, std::forward<TLambda>(lambda));
            break;
        case Fields::Invalid: [[fallthrough]];
        default: break;
        }
    }

    template <typename T, typename TLambda> static void VisitAll(T& obj, TLambda&& lambda)
    {
        auto fieldType = static_cast<Fields>(obj.index());
        std::visit([&](auto&& arg) { lambda(fieldType, arg); }, obj._variant);
    }
};

// template <> struct Stencil::Visitor<CLOpts2::CommandLineOptions> : Stencil::StructVisitor<CLOpts2::CommandLineOptions>
// {};

#endif
// SECTION END: Template specializations

// SECTION START: Inline Function Definitions
#if true

#endif
// SECTION END: Inline Function Definitions
