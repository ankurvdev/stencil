#pragma once
#include <stencil/stencil.h>

// SECTION START: DECLARATIONS
#if true

namespace UserData
{
struct UserData;
struct Identity;
struct RemoteHost;
}    // namespace UserData

template <> struct Stencil::TypeTraits<UserData::UserData>;
template <> struct Stencil::TypeTraits<UserData::Identity>;
template <> struct Stencil::TypeTraits<UserData::RemoteHost>;
#endif
// SECTION END: DECLARATIONS

// SECTION START: Definitions
#if true
namespace UserData
{
struct UserData :
    public ::Database2::OwnerT<::UserData::UserData,::UserData::RemoteHost>,
    public ::Database2::OwnerT<::UserData::UserData,::UserData::Identity>,
    public ::Stencil::TimestampedT<::UserData::UserData>,
    public Stencil::StructT<UserData>
{
    Stencil::Timestamp modified = Stencil::Timestamp{/*Initial Value*/};
    Stencil::Timestamp creation = Stencil::Timestamp{/*Initial Value*/};
};
struct Identity :
    public ::Database2::ObjectT<::UserData::UserData,::UserData::Identity>,
    public ::UuidObjectT<::UserData::Identity>,
    public ::Database2::EncryptedT<::UserData::Identity>,
    public ::Stencil::TimestampedT<::UserData::Identity>,
    public Stencil::StructT<Identity>
{
    ::Database2::ChildRef<Database2::WideString> username = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::Database2::ChildRef<Database2::WideString> password = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::Database2::ChildRef<Database2::WideString> privatekey = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::Database2::ChildRef<Database2::WideString> clientcert = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::Database2::ChildRef<Database2::WideString> secretcode = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
};
struct RemoteHost :
    public ::Database2::ObjectT<::UserData::UserData,::UserData::RemoteHost>,
    public ::UuidObjectT<::UserData::RemoteHost>,
    public ::Stencil::TimestampedT<::UserData::RemoteHost>,
    public Stencil::StructT<RemoteHost>
{
    ::Database2::ChildRef<Database2::WideString> name = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::Database2::ChildRef<Database2::WideString> uri = ::Database2::ChildRef<Database2::WideString>{/*Initial Value*/};
    ::UuidBasedId<::UserData::Identity> identity = ::UuidBasedId<::UserData::Identity>{::UuidBasedId<::UserData::Identity>::Create()};
};
}    // namespace UserData
#endif

// SECTION END: Definitions

// SECTION START: Template specializations
#if true

// SECTION:

template <> struct Stencil::TypeTraits<UserData::UserData>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<UserData::UserData>
{
    enum class Fields
    {
        Invalid,
        Field_modified
,        Field_creation
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<UserData::UserData>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<UserData::UserData>::Fields;

    static constexpr std::string_view Names[] = {
        "Invalid",
        "modified"
,        "creation"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }

    static Stencil::TypeTraitsForIndexable<UserData::UserData>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<UserData::UserData>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<UserData::UserData, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<UserData::UserData>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState modified = {Fields::Field_modified};
        ElemTxnState creation = {Fields::Field_creation};
    };

    using Txn               = Stencil::Transaction<UserData::UserData, TContainer>;
    using ElemType          = UserData::UserData;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_modified = Stencil::Transaction<Stencil::Timestamp, Txn>;
    using Transaction_creation = Stencil::Transaction<Stencil::Timestamp, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_modified::TxnState modified{};
        typename Transaction_creation::TxnState creation{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_modified))
        {
            auto txn = modified();
            lambda(Fields::Field_modified, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_modified))
        {
            auto txn = modified();
            lambda(Fields::Field_modified, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_creation))
        {
            auto txn = creation();
            lambda(Fields::Field_creation, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_creation))
        {
            auto txn = creation();
            lambda(Fields::Field_creation, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto modified()
    {
        return Stencil::CreateTransaction<Transaction_modified>(_elemState.modified, _txnStateForElem.modified, *this, _elem.modified);
    }

    auto creation()
    {
        return Stencil::CreateTransaction<Transaction_creation>(_elemState.creation, _txnStateForElem.creation, *this, _elem.creation);
    }

    void set_modified(Stencil::Timestamp&& val)
    {
        auto subtxn = modified();
        subtxn.Assign(std::forward<Stencil::Timestamp>(val));
    }

    void set_creation(Stencil::Timestamp&& val)
    {
        auto subtxn = creation();
        subtxn.Assign(std::forward<Stencil::Timestamp>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_modified:
        {
            auto txn = modified();
            return lambda(txn);
        }
        case Fields::Field_creation:
        {
            auto txn = creation();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = modified();
            lambda(Fields::Field_modified, txn, Elem().modified);
        }
        {
            auto txn = creation();
            lambda(Fields::Field_creation, txn, Elem().creation);
        }
    }
};

template <> struct Stencil::Visitor<UserData::UserData> : Stencil::VisitorT<UserData::UserData>
{
    using TData  = UserData::UserData;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_modified: return lambda(obj.modified);
        case Fields::Field_creation: return lambda(obj.creation);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_modified, obj.modified);
        lambda(Fields::Field_creation, obj.creation);
    }
};

template <> struct Stencil::TypeTraits<UserData::Identity>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<UserData::Identity>
{
    enum class Fields
    {
        Invalid,
        Field_username
,        Field_password
,        Field_privatekey
,        Field_clientcert
,        Field_secretcode
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<UserData::Identity>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<UserData::Identity>::Fields;

    static constexpr std::string_view Names[] = {
        "Invalid",
        "username"
,        "password"
,        "privatekey"
,        "clientcert"
,        "secretcode"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }

    static Stencil::TypeTraitsForIndexable<UserData::Identity>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<UserData::Identity>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<UserData::Identity, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<UserData::Identity>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState username = {Fields::Field_username};
        ElemTxnState password = {Fields::Field_password};
        ElemTxnState privatekey = {Fields::Field_privatekey};
        ElemTxnState clientcert = {Fields::Field_clientcert};
        ElemTxnState secretcode = {Fields::Field_secretcode};
    };

    using Txn               = Stencil::Transaction<UserData::Identity, TContainer>;
    using ElemType          = UserData::Identity;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_username = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_password = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_privatekey = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_clientcert = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_secretcode = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_username::TxnState username{};
        typename Transaction_password::TxnState password{};
        typename Transaction_privatekey::TxnState privatekey{};
        typename Transaction_clientcert::TxnState clientcert{};
        typename Transaction_secretcode::TxnState secretcode{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_username))
        {
            auto txn = username();
            lambda(Fields::Field_username, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_username))
        {
            auto txn = username();
            lambda(Fields::Field_username, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_password))
        {
            auto txn = password();
            lambda(Fields::Field_password, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_password))
        {
            auto txn = password();
            lambda(Fields::Field_password, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_privatekey))
        {
            auto txn = privatekey();
            lambda(Fields::Field_privatekey, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_privatekey))
        {
            auto txn = privatekey();
            lambda(Fields::Field_privatekey, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_clientcert))
        {
            auto txn = clientcert();
            lambda(Fields::Field_clientcert, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_clientcert))
        {
            auto txn = clientcert();
            lambda(Fields::Field_clientcert, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_secretcode))
        {
            auto txn = secretcode();
            lambda(Fields::Field_secretcode, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_secretcode))
        {
            auto txn = secretcode();
            lambda(Fields::Field_secretcode, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto username()
    {
        return Stencil::CreateTransaction<Transaction_username>(_elemState.username, _txnStateForElem.username, *this, _elem.username);
    }

    auto password()
    {
        return Stencil::CreateTransaction<Transaction_password>(_elemState.password, _txnStateForElem.password, *this, _elem.password);
    }

    auto privatekey()
    {
        return Stencil::CreateTransaction<Transaction_privatekey>(_elemState.privatekey, _txnStateForElem.privatekey, *this, _elem.privatekey);
    }

    auto clientcert()
    {
        return Stencil::CreateTransaction<Transaction_clientcert>(_elemState.clientcert, _txnStateForElem.clientcert, *this, _elem.clientcert);
    }

    auto secretcode()
    {
        return Stencil::CreateTransaction<Transaction_secretcode>(_elemState.secretcode, _txnStateForElem.secretcode, *this, _elem.secretcode);
    }

    void set_username(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = username();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_password(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = password();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_privatekey(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = privatekey();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_clientcert(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = clientcert();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_secretcode(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = secretcode();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_username:
        {
            auto txn = username();
            return lambda(txn);
        }
        case Fields::Field_password:
        {
            auto txn = password();
            return lambda(txn);
        }
        case Fields::Field_privatekey:
        {
            auto txn = privatekey();
            return lambda(txn);
        }
        case Fields::Field_clientcert:
        {
            auto txn = clientcert();
            return lambda(txn);
        }
        case Fields::Field_secretcode:
        {
            auto txn = secretcode();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = username();
            lambda(Fields::Field_username, txn, Elem().username);
        }
        {
            auto txn = password();
            lambda(Fields::Field_password, txn, Elem().password);
        }
        {
            auto txn = privatekey();
            lambda(Fields::Field_privatekey, txn, Elem().privatekey);
        }
        {
            auto txn = clientcert();
            lambda(Fields::Field_clientcert, txn, Elem().clientcert);
        }
        {
            auto txn = secretcode();
            lambda(Fields::Field_secretcode, txn, Elem().secretcode);
        }
    }
};

template <> struct Stencil::Visitor<UserData::Identity> : Stencil::VisitorT<UserData::Identity>
{
    using TData  = UserData::Identity;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_username: return lambda(obj.username);
        case Fields::Field_password: return lambda(obj.password);
        case Fields::Field_privatekey: return lambda(obj.privatekey);
        case Fields::Field_clientcert: return lambda(obj.clientcert);
        case Fields::Field_secretcode: return lambda(obj.secretcode);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_username, obj.username);
        lambda(Fields::Field_password, obj.password);
        lambda(Fields::Field_privatekey, obj.privatekey);
        lambda(Fields::Field_clientcert, obj.clientcert);
        lambda(Fields::Field_secretcode, obj.secretcode);
    }
};

template <> struct Stencil::TypeTraits<UserData::RemoteHost>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<UserData::RemoteHost>
{
    enum class Fields
    {
        Invalid,
        Field_name
,        Field_uri
,        Field_identity
    };

    using Key = Fields;
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<UserData::RemoteHost>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<UserData::RemoteHost>::Fields;

    static constexpr std::string_view Names[] = {
        "Invalid",
        "name"
,        "uri"
,        "identity"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }

    static Stencil::TypeTraitsForIndexable<UserData::RemoteHost>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<UserData::RemoteHost>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<UserData::RemoteHost, TContainer>
{
    using Fields = Stencil::TypeTraitsForIndexable<UserData::RemoteHost>::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState name = {Fields::Field_name};
        ElemTxnState uri = {Fields::Field_uri};
        ElemTxnState identity = {Fields::Field_identity};
    };

    using Txn               = Stencil::Transaction<UserData::RemoteHost, TContainer>;
    using ElemType          = UserData::RemoteHost;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_name = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_uri = Stencil::Transaction<::Database2::ChildRef<Database2::WideString>, Txn>;
    using Transaction_identity = Stencil::Transaction<::UuidBasedId<::UserData::Identity>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_name::TxnState name{};
        typename Transaction_uri::TxnState uri{};
        typename Transaction_identity::TxnState identity{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_name))
        {
            auto txn = name();
            lambda(Fields::Field_name, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_name))
        {
            auto txn = name();
            lambda(Fields::Field_name, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_uri))
        {
            auto txn = uri();
            lambda(Fields::Field_uri, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_uri))
        {
            auto txn = uri();
            lambda(Fields::Field_uri, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_identity))
        {
            auto txn = identity();
            lambda(Fields::Field_identity, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_identity))
        {
            auto txn = identity();
            lambda(Fields::Field_identity, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    void Assign(ElemType const& /* elem */) { TODO("DoNotCommit"); }
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto name()
    {
        return Stencil::CreateTransaction<Transaction_name>(_elemState.name, _txnStateForElem.name, *this, _elem.name);
    }

    auto uri()
    {
        return Stencil::CreateTransaction<Transaction_uri>(_elemState.uri, _txnStateForElem.uri, *this, _elem.uri);
    }

    auto identity()
    {
        return Stencil::CreateTransaction<Transaction_identity>(_elemState.identity, _txnStateForElem.identity, *this, _elem.identity);
    }

    void set_name(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = name();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_uri(::Database2::ChildRef<Database2::WideString>&& val)
    {
        auto subtxn = uri();
        subtxn.Assign(std::forward<::Database2::ChildRef<Database2::WideString>>(val));
    }

    void set_identity(::UuidBasedId<::UserData::Identity>&& val)
    {
        auto subtxn = identity();
        subtxn.Assign(std::forward<::UuidBasedId<::UserData::Identity>>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_name:
        {
            auto txn = name();
            return lambda(txn);
        }
        case Fields::Field_uri:
        {
            auto txn = uri();
            return lambda(txn);
        }
        case Fields::Field_identity:
        {
            auto txn = identity();
            return lambda(txn);
        }
        case Fields::Invalid: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = name();
            lambda(Fields::Field_name, txn, Elem().name);
        }
        {
            auto txn = uri();
            lambda(Fields::Field_uri, txn, Elem().uri);
        }
        {
            auto txn = identity();
            lambda(Fields::Field_identity, txn, Elem().identity);
        }
    }
};

template <> struct Stencil::Visitor<UserData::RemoteHost> : Stencil::VisitorT<UserData::RemoteHost>
{
    using TData  = UserData::RemoteHost;
    using Fields = TypeTraitsForIndexable<TData>::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_name: return lambda(obj.name);
        case Fields::Field_uri: return lambda(obj.uri);
        case Fields::Field_identity: return lambda(obj.identity);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Fields::Field_name, obj.name);
        lambda(Fields::Field_uri, obj.uri);
        lambda(Fields::Field_identity, obj.identity);
    }
};

#endif
// SECTION END: Template specializations

// SECTION START: Inline Function Definitions
#if true

#endif
// SECTION END: Inline Function Definitions
