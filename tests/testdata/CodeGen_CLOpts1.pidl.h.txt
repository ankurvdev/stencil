#pragma once
#include <stencil/stencil.h>
// SECTION START: DECLARATIONS
#if true

namespace CLOpts1
{
struct CommandLineOptions;
struct SimpleObj;
struct ObjWithList;
struct CLOptsTest;
}    // namespace CLOpts1

template <> struct Stencil::TypeTraits<CLOpts1::CommandLineOptions>;
template <> struct Stencil::TypeTraits<CLOpts1::SimpleObj>;
template <> struct Stencil::TypeTraits<CLOpts1::ObjWithList>;
template <> struct Stencil::TypeTraits<CLOpts1::CLOptsTest>;
#endif
// SECTION END: DECLARATIONS

// SECTION START: Definitions
#if true
namespace CLOpts1
{
struct CommandLineOptions :
    public Stencil::StructT<CommandLineOptions>
{
    shared_string workingDirectory = {};
    std::vector<shared_string> libraries = {};
    std::vector<shared_string> scan = {};
    int32_t httpsPort = 3443;
    bool daemon = 0;
    bool quiet = 1;
    shared_string out_dir = ".";
};
struct SimpleObj :
    public Stencil::StructT<SimpleObj>
{
    shared_string field1 = {};
    shared_string field2 = {};
};
struct ObjWithList :
    public Stencil::StructT<ObjWithList>
{
    std::vector<shared_string> field1 = {};
};
struct CLOptsTest :
    public Stencil::StructT<CLOptsTest>
{
    shared_string key1 = {};
    std::vector<int32_t> listofint = {};
    std::vector<std::vector<int32_t>> listoflist = {};
    std::vector<::CLOpts1::SimpleObj> listofobj = {};
    ::CLOpts1::ObjWithList objoflist = {};
    shared_string key2 = {};
};
}    // namespace CLOpts1
#endif

// SECTION END: Definitions

// SECTION START: Template specializations
#if true

// SECTION:

template <> struct Stencil::TypeTraits<CLOpts1::CommandLineOptions>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>
{
    enum class Fields
    {
        Invalid,
        Field_workingDirectory
,        Field_libraries
,        Field_scan
,        Field_httpsPort
,        Field_daemon
,        Field_quiet
,        Field_out_dir
    };

    struct Field_workingDirectoryT
    {};
    struct Field_librariesT
    {};
    struct Field_scanT
    {};
    struct Field_httpsPortT
    {};
    struct Field_daemonT
    {};
    struct Field_quietT
    {};
    struct Field_out_dirT
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "workingDirectory"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "workingDirectory";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_workingDirectory);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_workingDirectory) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "libraries"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "libraries";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_libraries);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_libraries) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "scan"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "scan";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_scan);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_scan) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "httpsPort"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "httpsPort";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_httpsPort);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_httpsPort) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "daemon"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "daemon";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_daemon);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_daemon) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "quiet"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "quiet";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_quiet);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_quiet) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "out_dir"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "out_dir";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_out_dir);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_out_dir) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT>
{
    static auto Value() { return "Location of path where it'll store its database and other info"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_workingDirectoryT>
{
    static auto Value() { return "Working Directory"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT>
{
    static auto Value() { return "Locations of Directories to store files"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_librariesT>
{
    static auto Value() { return "Library Directories"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT>
{
    static auto Value() { return "List of Directories to scan for Document files"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_scanT>
{
    static auto Value() { return "Scan Directories"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT>
{
    static auto Value() { return "TCP port on which to listen for incoming HTTP connections"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_httpsPortT>
{
    static auto Value() { return "Listen Port"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT>
{
    static auto Value() { return "Run as daemon"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_daemonT>
{
    static auto Value() { return "Run as Daemon"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT>
{
    static auto Value() { return "Run Quietly"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_quietT>
{
    static auto Value() { return "Run Quietly"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Description,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT>
{
    static auto Value() { return "Location of the output directory"; }
};

template <>
struct Stencil::Attribute<Stencil::AttributeType::Name1,
                          Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Field_out_dirT>
{
    static auto Value() { return "Output Directory"; }
};

template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "workingDirectory"
,        "libraries"
,        "scan"
,        "httpsPort"
,        "daemon"
,        "quiet"
,        "out_dir"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts1::CommandLineOptions, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<CLOpts1::CommandLineOptions>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState workingDirectory = {Fields::Field_workingDirectory};
        ElemTxnState libraries = {Fields::Field_libraries};
        ElemTxnState scan = {Fields::Field_scan};
        ElemTxnState httpsPort = {Fields::Field_httpsPort};
        ElemTxnState daemon = {Fields::Field_daemon};
        ElemTxnState quiet = {Fields::Field_quiet};
        ElemTxnState out_dir = {Fields::Field_out_dir};
    };

    using Txn               = Stencil::Transaction<CLOpts1::CommandLineOptions, TContainer>;
    using ElemType          = CLOpts1::CommandLineOptions;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_workingDirectory = Stencil::Transaction<shared_string, Txn>;
    using Transaction_libraries = Stencil::Transaction<std::vector<shared_string>, Txn>;
    using Transaction_scan = Stencil::Transaction<std::vector<shared_string>, Txn>;
    using Transaction_httpsPort = Stencil::Transaction<int32_t, Txn>;
    using Transaction_daemon = Stencil::Transaction<bool, Txn>;
    using Transaction_quiet = Stencil::Transaction<bool, Txn>;
    using Transaction_out_dir = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_workingDirectory::TxnState workingDirectory{};
        typename Transaction_libraries::TxnState libraries{};
        typename Transaction_scan::TxnState scan{};
        typename Transaction_httpsPort::TxnState httpsPort{};
        typename Transaction_daemon::TxnState daemon{};
        typename Transaction_quiet::TxnState quiet{};
        typename Transaction_out_dir::TxnState out_dir{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_workingDirectory))
        {
            auto txn = workingDirectory();
            lambda(Fields::Field_workingDirectory, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_workingDirectory))
        {
            auto txn = workingDirectory();
            lambda(Fields::Field_workingDirectory, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_libraries))
        {
            auto txn = libraries();
            lambda(Fields::Field_libraries, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_libraries))
        {
            auto txn = libraries();
            lambda(Fields::Field_libraries, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_scan))
        {
            auto txn = scan();
            lambda(Fields::Field_scan, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_scan))
        {
            auto txn = scan();
            lambda(Fields::Field_scan, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_httpsPort))
        {
            auto txn = httpsPort();
            lambda(Fields::Field_httpsPort, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_httpsPort))
        {
            auto txn = httpsPort();
            lambda(Fields::Field_httpsPort, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_daemon))
        {
            auto txn = daemon();
            lambda(Fields::Field_daemon, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_daemon))
        {
            auto txn = daemon();
            lambda(Fields::Field_daemon, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_quiet))
        {
            auto txn = quiet();
            lambda(Fields::Field_quiet, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_quiet))
        {
            auto txn = quiet();
            lambda(Fields::Field_quiet, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_out_dir))
        {
            auto txn = out_dir();
            lambda(Fields::Field_out_dir, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_out_dir))
        {
            auto txn = out_dir();
            lambda(Fields::Field_out_dir, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto workingDirectory()
    {
        return Stencil::CreateTransaction<Transaction_workingDirectory>(_elemState.workingDirectory, _txnStateForElem.workingDirectory, *this, _elem.workingDirectory);
    }

    auto libraries()
    {
        return Stencil::CreateTransaction<Transaction_libraries>(_elemState.libraries, _txnStateForElem.libraries, *this, _elem.libraries);
    }

    auto scan()
    {
        return Stencil::CreateTransaction<Transaction_scan>(_elemState.scan, _txnStateForElem.scan, *this, _elem.scan);
    }

    auto httpsPort()
    {
        return Stencil::CreateTransaction<Transaction_httpsPort>(_elemState.httpsPort, _txnStateForElem.httpsPort, *this, _elem.httpsPort);
    }

    auto daemon()
    {
        return Stencil::CreateTransaction<Transaction_daemon>(_elemState.daemon, _txnStateForElem.daemon, *this, _elem.daemon);
    }

    auto quiet()
    {
        return Stencil::CreateTransaction<Transaction_quiet>(_elemState.quiet, _txnStateForElem.quiet, *this, _elem.quiet);
    }

    auto out_dir()
    {
        return Stencil::CreateTransaction<Transaction_out_dir>(_elemState.out_dir, _txnStateForElem.out_dir, *this, _elem.out_dir);
    }

    void set_workingDirectory(shared_string&& val)
    {
        auto subtxn = workingDirectory();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_libraries(std::vector<shared_string>&& val)
    {
        auto subtxn = libraries();
        subtxn.Assign(std::forward<std::vector<shared_string>>(val));
    }

    void add_libraries(shared_string&& args)
    {
        _MarkFieldEdited(Fields::Field_libraries);
        auto txn = libraries();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_libraries(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_libraries);
        auto txn = libraries();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_libraries(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_libraries);
        auto txn = libraries();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    void set_scan(std::vector<shared_string>&& val)
    {
        auto subtxn = scan();
        subtxn.Assign(std::forward<std::vector<shared_string>>(val));
    }

    void add_scan(shared_string&& args)
    {
        _MarkFieldEdited(Fields::Field_scan);
        auto txn = scan();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_scan(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_scan);
        auto txn = scan();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_scan(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_scan);
        auto txn = scan();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    void set_httpsPort(int32_t&& val)
    {
        auto subtxn = httpsPort();
        subtxn.Assign(std::forward<int32_t>(val));
    }

    void set_daemon(bool&& val)
    {
        auto subtxn = daemon();
        subtxn.Assign(std::forward<bool>(val));
    }

    void set_quiet(bool&& val)
    {
        auto subtxn = quiet();
        subtxn.Assign(std::forward<bool>(val));
    }

    void set_out_dir(shared_string&& val)
    {
        auto subtxn = out_dir();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_workingDirectory:
        {
            auto txn = workingDirectory();
            return lambda(txn);
        }
        case Fields::Field_libraries:
        {
            auto txn = libraries();
            return lambda(txn);
        }
        case Fields::Field_scan:
        {
            auto txn = scan();
            return lambda(txn);
        }
        case Fields::Field_httpsPort:
        {
            auto txn = httpsPort();
            return lambda(txn);
        }
        case Fields::Field_daemon:
        {
            auto txn = daemon();
            return lambda(txn);
        }
        case Fields::Field_quiet:
        {
            auto txn = quiet();
            return lambda(txn);
        }
        case Fields::Field_out_dir:
        {
            auto txn = out_dir();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = workingDirectory();
            lambda(Traits::Field_workingDirectoryT{}, txn, Elem().workingDirectory);
        }
        {
            auto txn = libraries();
            lambda(Traits::Field_librariesT{}, txn, Elem().libraries);
        }
        {
            auto txn = scan();
            lambda(Traits::Field_scanT{}, txn, Elem().scan);
        }
        {
            auto txn = httpsPort();
            lambda(Traits::Field_httpsPortT{}, txn, Elem().httpsPort);
        }
        {
            auto txn = daemon();
            lambda(Traits::Field_daemonT{}, txn, Elem().daemon);
        }
        {
            auto txn = quiet();
            lambda(Traits::Field_quietT{}, txn, Elem().quiet);
        }
        {
            auto txn = out_dir();
            lambda(Traits::Field_out_dirT{}, txn, Elem().out_dir);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts1::CommandLineOptions> : Stencil::VisitorT<CLOpts1::CommandLineOptions>
{
    using TData  = CLOpts1::CommandLineOptions;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_workingDirectory: return lambda(obj.workingDirectory);
        case Fields::Field_libraries: return lambda(obj.libraries);
        case Fields::Field_scan: return lambda(obj.scan);
        case Fields::Field_httpsPort: return lambda(obj.httpsPort);
        case Fields::Field_daemon: return lambda(obj.daemon);
        case Fields::Field_quiet: return lambda(obj.quiet);
        case Fields::Field_out_dir: return lambda(obj.out_dir);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_workingDirectoryT{}, obj.workingDirectory);
        lambda(Traits::Field_librariesT{}, obj.libraries);
        lambda(Traits::Field_scanT{}, obj.scan);
        lambda(Traits::Field_httpsPortT{}, obj.httpsPort);
        lambda(Traits::Field_daemonT{}, obj.daemon);
        lambda(Traits::Field_quietT{}, obj.quiet);
        lambda(Traits::Field_out_dirT{}, obj.out_dir);
    }
};

template <> struct Stencil::Comparator<CLOpts1::CommandLineOptions, CLOpts1::CommandLineOptions>
{
    using ThisType = CLOpts1::CommandLineOptions;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.workingDirectory, obj2.workingDirectory)
               && Stencil::AreEqual(obj1.libraries, obj2.libraries)
               && Stencil::AreEqual(obj1.scan, obj2.scan)
               && Stencil::AreEqual(obj1.httpsPort, obj2.httpsPort)
               && Stencil::AreEqual(obj1.daemon, obj2.daemon)
               && Stencil::AreEqual(obj1.quiet, obj2.quiet)
               && Stencil::AreEqual(obj1.out_dir, obj2.out_dir)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts1::CommandLineOptions> :
    public Stencil::Database::RecordT<CLOpts1::CommandLineOptions>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type workingDirectory{};
    Stencil::Database::RecordNest<std::vector<shared_string>>::Type libraries{};
    Stencil::Database::RecordNest<std::vector<shared_string>>::Type scan{};
    Stencil::Database::RecordNest<int32_t>::Type httpsPort{};
    Stencil::Database::RecordNest<bool>::Type daemon{};
    Stencil::Database::RecordNest<bool>::Type quiet{};
    Stencil::Database::RecordNest<shared_string>::Type out_dir{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts1::CommandLineOptions>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::vector<shared_string>>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::vector<shared_string>>::RecordTypes,
        typename Stencil::Database::RecordTraits<int32_t>::RecordTypes,
        typename Stencil::Database::RecordTraits<bool>::RecordTypes,
        typename Stencil::Database::RecordTraits<bool>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts1::CommandLineOptions>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts1::CommandLineOptions>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts1::CommandLineOptions const&                      obj,
                              Stencil::Database::Record<CLOpts1::CommandLineOptions>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.workingDirectory, rec.workingDirectory);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.libraries, rec.libraries);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.scan, rec.scan);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.httpsPort, rec.httpsPort);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.daemon, rec.daemon);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.quiet, rec.quiet);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.out_dir, rec.out_dir);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts1::CommandLineOptions>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts1::CommandLineOptions>>
{
    using TData  = CLOpts1::CommandLineOptions;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_workingDirectory: return lambda(obj.workingDirectory);
        case Fields::Field_libraries: return lambda(obj.libraries);
        case Fields::Field_scan: return lambda(obj.scan);
        case Fields::Field_httpsPort: return lambda(obj.httpsPort);
        case Fields::Field_daemon: return lambda(obj.daemon);
        case Fields::Field_quiet: return lambda(obj.quiet);
        case Fields::Field_out_dir: return lambda(obj.out_dir);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_workingDirectoryT{}, obj.workingDirectory);
        lambda(Traits::Field_librariesT{}, obj.libraries);
        lambda(Traits::Field_scanT{}, obj.scan);
        lambda(Traits::Field_httpsPortT{}, obj.httpsPort);
        lambda(Traits::Field_daemonT{}, obj.daemon);
        lambda(Traits::Field_quietT{}, obj.quiet);
        lambda(Traits::Field_out_dirT{}, obj.out_dir);
    }
};

template <> struct Stencil::TypeTraits<CLOpts1::SimpleObj>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>
{
    enum class Fields
    {
        Invalid,
        Field_field1
,        Field_field2
    };

    struct Field_field1T
    {};
    struct Field_field2T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "field1"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "field1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_field1);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_field1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field2T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field2T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "field2"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "field2";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field2T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Field_field2T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_field2);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_field2) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "field1"
,        "field2"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts1::SimpleObj, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<CLOpts1::SimpleObj>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState field1 = {Fields::Field_field1};
        ElemTxnState field2 = {Fields::Field_field2};
    };

    using Txn               = Stencil::Transaction<CLOpts1::SimpleObj, TContainer>;
    using ElemType          = CLOpts1::SimpleObj;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_field1 = Stencil::Transaction<shared_string, Txn>;
    using Transaction_field2 = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_field1::TxnState field1{};
        typename Transaction_field2::TxnState field2{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_field1))
        {
            auto txn = field1();
            lambda(Fields::Field_field1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_field1))
        {
            auto txn = field1();
            lambda(Fields::Field_field1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_field2))
        {
            auto txn = field2();
            lambda(Fields::Field_field2, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_field2))
        {
            auto txn = field2();
            lambda(Fields::Field_field2, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto field1()
    {
        return Stencil::CreateTransaction<Transaction_field1>(_elemState.field1, _txnStateForElem.field1, *this, _elem.field1);
    }

    auto field2()
    {
        return Stencil::CreateTransaction<Transaction_field2>(_elemState.field2, _txnStateForElem.field2, *this, _elem.field2);
    }

    void set_field1(shared_string&& val)
    {
        auto subtxn = field1();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_field2(shared_string&& val)
    {
        auto subtxn = field2();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_field1:
        {
            auto txn = field1();
            return lambda(txn);
        }
        case Fields::Field_field2:
        {
            auto txn = field2();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = field1();
            lambda(Traits::Field_field1T{}, txn, Elem().field1);
        }
        {
            auto txn = field2();
            lambda(Traits::Field_field2T{}, txn, Elem().field2);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts1::SimpleObj> : Stencil::VisitorT<CLOpts1::SimpleObj>
{
    using TData  = CLOpts1::SimpleObj;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_field1: return lambda(obj.field1);
        case Fields::Field_field2: return lambda(obj.field2);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_field1T{}, obj.field1);
        lambda(Traits::Field_field2T{}, obj.field2);
    }
};

template <> struct Stencil::Comparator<CLOpts1::SimpleObj, CLOpts1::SimpleObj>
{
    using ThisType = CLOpts1::SimpleObj;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.field1, obj2.field1)
               && Stencil::AreEqual(obj1.field2, obj2.field2)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts1::SimpleObj> :
    public Stencil::Database::RecordT<CLOpts1::SimpleObj>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type field1{};
    Stencil::Database::RecordNest<shared_string>::Type field2{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts1::SimpleObj>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts1::SimpleObj>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts1::SimpleObj>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts1::SimpleObj const&                      obj,
                              Stencil::Database::Record<CLOpts1::SimpleObj>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.field1, rec.field1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.field2, rec.field2);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts1::SimpleObj>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts1::SimpleObj>>
{
    using TData  = CLOpts1::SimpleObj;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_field1: return lambda(obj.field1);
        case Fields::Field_field2: return lambda(obj.field2);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_field1T{}, obj.field1);
        lambda(Traits::Field_field2T{}, obj.field2);
    }
};

template <> struct Stencil::TypeTraits<CLOpts1::ObjWithList>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>
{
    enum class Fields
    {
        Invalid,
        Field_field1
    };

    struct Field_field1T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Field_field1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Field_field1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "field1"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "field1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Field_field1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Field_field1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_field1);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_field1) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "field1"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts1::ObjWithList, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<CLOpts1::ObjWithList>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState field1 = {Fields::Field_field1};
    };

    using Txn               = Stencil::Transaction<CLOpts1::ObjWithList, TContainer>;
    using ElemType          = CLOpts1::ObjWithList;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_field1 = Stencil::Transaction<std::vector<shared_string>, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_field1::TxnState field1{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_field1))
        {
            auto txn = field1();
            lambda(Fields::Field_field1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_field1))
        {
            auto txn = field1();
            lambda(Fields::Field_field1, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto field1()
    {
        return Stencil::CreateTransaction<Transaction_field1>(_elemState.field1, _txnStateForElem.field1, *this, _elem.field1);
    }

    void set_field1(std::vector<shared_string>&& val)
    {
        auto subtxn = field1();
        subtxn.Assign(std::forward<std::vector<shared_string>>(val));
    }

    void add_field1(shared_string&& args)
    {
        _MarkFieldEdited(Fields::Field_field1);
        auto txn = field1();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_field1(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_field1);
        auto txn = field1();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_field1(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_field1);
        auto txn = field1();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_field1:
        {
            auto txn = field1();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = field1();
            lambda(Traits::Field_field1T{}, txn, Elem().field1);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts1::ObjWithList> : Stencil::VisitorT<CLOpts1::ObjWithList>
{
    using TData  = CLOpts1::ObjWithList;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_field1: return lambda(obj.field1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_field1T{}, obj.field1);
    }
};

template <> struct Stencil::Comparator<CLOpts1::ObjWithList, CLOpts1::ObjWithList>
{
    using ThisType = CLOpts1::ObjWithList;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.field1, obj2.field1)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts1::ObjWithList> :
    public Stencil::Database::RecordT<CLOpts1::ObjWithList>
{
    public:
    Stencil::Database::RecordNest<std::vector<shared_string>>::Type field1{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts1::ObjWithList>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<std::vector<shared_string>>::RecordTypes,
        std::tuple<CLOpts1::ObjWithList>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts1::ObjWithList>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts1::ObjWithList const&                      obj,
                              Stencil::Database::Record<CLOpts1::ObjWithList>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.field1, rec.field1);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts1::ObjWithList>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts1::ObjWithList>>
{
    using TData  = CLOpts1::ObjWithList;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_field1: return lambda(obj.field1);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_field1T{}, obj.field1);
    }
};

template <> struct Stencil::TypeTraits<CLOpts1::CLOptsTest>
{
    using Categories = std::tuple<Stencil::Category::Indexable>;
};

template <> struct Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>
{
    enum class Fields
    {
        Invalid,
        Field_key1
,        Field_listofint
,        Field_listoflist
,        Field_listofobj
,        Field_objoflist
,        Field_key2
    };

    struct Field_key1T
    {};
    struct Field_listofintT
    {};
    struct Field_listoflistT
    {};
    struct Field_listofobjT
    {};
    struct Field_objoflistT
    {};
    struct Field_key2T
    {};
    using Key = Fields;
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key1T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key1T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "key1"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "key1";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key1T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key1T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_key1);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_key1) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofintT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofintT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "listofint"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "listofint";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofintT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofintT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_listofint);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_listofint) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listoflistT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listoflistT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "listoflist"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "listoflist";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listoflistT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listoflistT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_listoflist);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_listoflist) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofobjT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofobjT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "listofobj"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "listofobj";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofobjT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_listofobjT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_listofobj);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_listofobj) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_objoflistT, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_objoflistT;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "objoflist"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "objoflist";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_objoflistT, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_objoflistT;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_objoflist);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_objoflist) { throw std::invalid_argument("Invalid"); }
    }
};
template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key2T, Stencil::ProtocolString>
{
    using T = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key2T;
    template <typename Context> static auto Write(Context& ctx, T const& /* obj */) { fmt::print(ctx, "{}", "key2"); }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        std::string_view name = "key2";
        if (!std::equal(std::begin(ctx), std::end(ctx), std::begin(name), std::end(name), [](auto l, auto r) {
                return std::tolower(l) == std::tolower(r);
            }))
        {
            throw std::invalid_argument("Invalid");
        }
    }
};

template <>
struct Stencil::SerDes<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key2T, Stencil::ProtocolBinary>
{
    using Fields = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    using T      = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Field_key2T;

    template <typename Context> static auto Write(Context& ctx, T const& /* obj */)
    {
        ctx << static_cast<uint32_t>(Fields::Field_key2);
    }

    template <typename Context> static auto Read(T& obj, Context& ctx)
    {
        auto val = static_cast<Fields>(ctx.template read<uint32_t>());
        if (val != Fields::Field_key2) { throw std::invalid_argument("Invalid"); }
    }
};
template <> struct Stencil::EnumTraits<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields>
{
    using Enum = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields;
    SUPPRESS_WARNINGS_START
    SUPPRESS_CLANG_WARNING("-Wunsafe-buffer-usage")
    static constexpr std::string_view Names[] = {
        "Invalid",
        "key1"
,        "listofint"
,        "listoflist"
,        "listofobj"
,        "objoflist"
,        "key2"
    };

    static std::string_view ToString(Enum type) { return Names[static_cast<size_t>(type)]; }
    SUPPRESS_WARNINGS_END
    static Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields ForIndex(size_t index)
    {
        return static_cast<Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>::Fields>(index);
    }
};

template <Stencil::ConceptTransaction TContainer> struct Stencil::Transaction<CLOpts1::CLOptsTest, TContainer>
{
    using Traits = Stencil::TypeTraitsForIndexable<CLOpts1::CLOptsTest>;

    using Fields = Traits::Fields;

    struct ElemTxnState
    {
        Fields field;
    };

    struct TxnStateForElem
    {
        ElemTxnState key1 = {Fields::Field_key1};
        ElemTxnState listofint = {Fields::Field_listofint};
        ElemTxnState listoflist = {Fields::Field_listoflist};
        ElemTxnState listofobj = {Fields::Field_listofobj};
        ElemTxnState objoflist = {Fields::Field_objoflist};
        ElemTxnState key2 = {Fields::Field_key2};
    };

    using Txn               = Stencil::Transaction<CLOpts1::CLOptsTest, TContainer>;
    using ElemType          = CLOpts1::CLOptsTest;
    using ContainerTxnState = typename TContainer::ElemTxnState;

    using Transaction_key1 = Stencil::Transaction<shared_string, Txn>;
    using Transaction_listofint = Stencil::Transaction<std::vector<int32_t>, Txn>;
    using Transaction_listoflist = Stencil::Transaction<std::vector<std::vector<int32_t>>, Txn>;
    using Transaction_listofobj = Stencil::Transaction<std::vector<::CLOpts1::SimpleObj>, Txn>;
    using Transaction_objoflist = Stencil::Transaction<::CLOpts1::ObjWithList, Txn>;
    using Transaction_key2 = Stencil::Transaction<shared_string, Txn>;
    struct TxnState
    {
        std::bitset<64> assigntracker;    // TODO1
        std::bitset<64> edittracker;      // TODO1
        typename Transaction_key1::TxnState key1{};
        typename Transaction_listofint::TxnState listofint{};
        typename Transaction_listoflist::TxnState listoflist{};
        typename Transaction_listofobj::TxnState listofobj{};
        typename Transaction_objoflist::TxnState objoflist{};
        typename Transaction_key2::TxnState key2{};
    };

    Transaction(TxnState& elemState, ContainerTxnState& containerState, TContainer& container, ElemType& elem) :
        _elemState(elemState), _containerState(containerState), _container(container), _elem(elem)
    {}

    ~Transaction()
    {
        if (IsChanged())
        {
            Stencil::TimestampedT<ElemType>::UpdateTimestamp(_elem);
            _container.NotifyElementEdited_(_containerState);
        }
    }

    CLASS_DELETE_COPY_AND_MOVE(Transaction);

    ElemType const& Elem() const { return _elem; }

    bool _IsFieldAssigned(Fields key) const { return _elemState.assigntracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldEdited(Fields key) const { return _elemState.edittracker.test(static_cast<uint8_t>(key)); }
    bool _IsFieldChanged(Fields key) const { return _IsFieldAssigned(key) || _IsFieldEdited(key); }
    void _MarkFieldAssigned(Fields key) { _elemState.assigntracker.set(static_cast<uint8_t>(key)); }
    void _MarkFieldEdited(Fields key) { _elemState.edittracker.set(static_cast<uint8_t>(key)); }

    size_t _CountFieldsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).count(); }

    void NotifyElementAssigned_(ElemTxnState const& elemTxnState)
    {
        _MarkFieldAssigned(elemTxnState.field);
        Stencil::OptionalPropsT<ElemType>::MarkValid(_elem, elemTxnState.field);
    }

    void NotifyElementEdited_(ElemTxnState const& elemTxnState) { _MarkFieldEdited(elemTxnState.field); }

    bool IsElementChanged(ElemTxnState const& elemTxnState) { return _IsFieldChanged(elemTxnState.field); }
    bool IsChanged() const { return (_elemState.assigntracker | _elemState.edittracker).any(); }

    template <typename TLambda> void VisitChanges([[maybe_unused]] TLambda&& lambda)
    {
        if (_IsFieldAssigned(Fields::Field_key1))
        {
            auto txn = key1();
            lambda(Fields::Field_key1, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_key1))
        {
            auto txn = key1();
            lambda(Fields::Field_key1, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_listofint))
        {
            auto txn = listofint();
            lambda(Fields::Field_listofint, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_listofint))
        {
            auto txn = listofint();
            lambda(Fields::Field_listofint, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_listoflist))
        {
            auto txn = listoflist();
            lambda(Fields::Field_listoflist, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_listoflist))
        {
            auto txn = listoflist();
            lambda(Fields::Field_listoflist, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_listofobj))
        {
            auto txn = listofobj();
            lambda(Fields::Field_listofobj, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_listofobj))
        {
            auto txn = listofobj();
            lambda(Fields::Field_listofobj, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_objoflist))
        {
            auto txn = objoflist();
            lambda(Fields::Field_objoflist, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_objoflist))
        {
            auto txn = objoflist();
            lambda(Fields::Field_objoflist, uint8_t{3u}, uint32_t{0u}, txn);
        }
        if (_IsFieldAssigned(Fields::Field_key2))
        {
            auto txn = key2();
            lambda(Fields::Field_key2, uint8_t{0u}, uint32_t{0u}, txn);
        }
        else if (_IsFieldEdited(Fields::Field_key2))
        {
            auto txn = key2();
            lambda(Fields::Field_key2, uint8_t{3u}, uint32_t{0u}, txn);
        }
    }

    void Assign(ElemType&& elem)
    {
        // if (Stencil::AreEqual(_elem, elem)) return;
        std::swap(_elem, elem);
        _container.NotifyElementAssigned_(_containerState);
    }

    // void Assign(ElemType const& /* elem */);
    void Add(ElemType&& /* elem */) { std::logic_error("Invalid operation"); }

    template <typename T> void Remove(T /* key */) { std::logic_error("Invalid operation"); }

    private:
    TxnStateForElem    _txnStateForElem{};
    TxnState&          _elemState;
    ContainerTxnState& _containerState;
    TContainer&        _container;
    ElemType&          _elem;

    public:
    auto key1()
    {
        return Stencil::CreateTransaction<Transaction_key1>(_elemState.key1, _txnStateForElem.key1, *this, _elem.key1);
    }

    auto listofint()
    {
        return Stencil::CreateTransaction<Transaction_listofint>(_elemState.listofint, _txnStateForElem.listofint, *this, _elem.listofint);
    }

    auto listoflist()
    {
        return Stencil::CreateTransaction<Transaction_listoflist>(_elemState.listoflist, _txnStateForElem.listoflist, *this, _elem.listoflist);
    }

    auto listofobj()
    {
        return Stencil::CreateTransaction<Transaction_listofobj>(_elemState.listofobj, _txnStateForElem.listofobj, *this, _elem.listofobj);
    }

    auto objoflist()
    {
        return Stencil::CreateTransaction<Transaction_objoflist>(_elemState.objoflist, _txnStateForElem.objoflist, *this, _elem.objoflist);
    }

    auto key2()
    {
        return Stencil::CreateTransaction<Transaction_key2>(_elemState.key2, _txnStateForElem.key2, *this, _elem.key2);
    }

    void set_key1(shared_string&& val)
    {
        auto subtxn = key1();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    void set_listofint(std::vector<int32_t>&& val)
    {
        auto subtxn = listofint();
        subtxn.Assign(std::forward<std::vector<int32_t>>(val));
    }

    void add_listofint(int32_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listofint);
        auto txn = listofint();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_listofint(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listofint);
        auto txn = listofint();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_listofint(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listofint);
        auto txn = listofint();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    void set_listoflist(std::vector<std::vector<int32_t>>&& val)
    {
        auto subtxn = listoflist();
        subtxn.Assign(std::forward<std::vector<std::vector<int32_t>>>(val));
    }

    void add_listoflist(std::vector<int32_t>&& args)
    {
        _MarkFieldEdited(Fields::Field_listoflist);
        auto txn = listoflist();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_listoflist(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listoflist);
        auto txn = listoflist();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_listoflist(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listoflist);
        auto txn = listoflist();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    void set_listofobj(std::vector<::CLOpts1::SimpleObj>&& val)
    {
        auto subtxn = listofobj();
        subtxn.Assign(std::forward<std::vector<::CLOpts1::SimpleObj>>(val));
    }

    void add_listofobj(::CLOpts1::SimpleObj&& args)
    {
        _MarkFieldEdited(Fields::Field_listofobj);
        auto txn = listofobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::add(txn, std::move(args));
    }
    void remove_listofobj(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listofobj);
        auto txn = listofobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::remove(txn, std::move(args));
    }
    auto edit_listofobj(size_t&& args)
    {
        _MarkFieldEdited(Fields::Field_listofobj);
        auto txn = listofobj();
        return Stencil::Mutators<std::remove_reference_t<decltype(txn)>>::edit(txn, std::move(args));
    }
    void set_objoflist(::CLOpts1::ObjWithList&& val)
    {
        auto subtxn = objoflist();
        subtxn.Assign(std::forward<::CLOpts1::ObjWithList>(val));
    }

    void set_key2(shared_string&& val)
    {
        auto subtxn = key2();
        subtxn.Assign(std::forward<shared_string>(val));
    }

    template <typename TLambda> auto Edit(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        switch (index)
        {
        case Fields::Field_key1:
        {
            auto txn = key1();
            return lambda(txn);
        }
        case Fields::Field_listofint:
        {
            auto txn = listofint();
            return lambda(txn);
        }
        case Fields::Field_listoflist:
        {
            auto txn = listoflist();
            return lambda(txn);
        }
        case Fields::Field_listofobj:
        {
            auto txn = listofobj();
            return lambda(txn);
        }
        case Fields::Field_objoflist:
        {
            auto txn = objoflist();
            return lambda(txn);
        }
        case Fields::Field_key2:
        {
            auto txn = key2();
            return lambda(txn);
        }
        case Fields::Invalid: [[fallthrough]];
        default: throw std::invalid_argument("Asked to visit invalid field");
        }
    }

    template <typename TLambda> auto Assign(Fields index, [[maybe_unused]] TLambda&& lambda)
    {
        return Edit(index, std::forward<TLambda>(lambda));
    }

    template <typename TLambda> void VisitAll([[maybe_unused]] TLambda&& lambda)
    {
        {
            auto txn = key1();
            lambda(Traits::Field_key1T{}, txn, Elem().key1);
        }
        {
            auto txn = listofint();
            lambda(Traits::Field_listofintT{}, txn, Elem().listofint);
        }
        {
            auto txn = listoflist();
            lambda(Traits::Field_listoflistT{}, txn, Elem().listoflist);
        }
        {
            auto txn = listofobj();
            lambda(Traits::Field_listofobjT{}, txn, Elem().listofobj);
        }
        {
            auto txn = objoflist();
            lambda(Traits::Field_objoflistT{}, txn, Elem().objoflist);
        }
        {
            auto txn = key2();
            lambda(Traits::Field_key2T{}, txn, Elem().key2);
        }
    }
};

template <> struct Stencil::Visitor<CLOpts1::CLOptsTest> : Stencil::VisitorT<CLOpts1::CLOptsTest>
{
    using TData  = CLOpts1::CLOptsTest;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_key1: return lambda(obj.key1);
        case Fields::Field_listofint: return lambda(obj.listofint);
        case Fields::Field_listoflist: return lambda(obj.listoflist);
        case Fields::Field_listofobj: return lambda(obj.listofobj);
        case Fields::Field_objoflist: return lambda(obj.objoflist);
        case Fields::Field_key2: return lambda(obj.key2);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_key1T{}, obj.key1);
        lambda(Traits::Field_listofintT{}, obj.listofint);
        lambda(Traits::Field_listoflistT{}, obj.listoflist);
        lambda(Traits::Field_listofobjT{}, obj.listofobj);
        lambda(Traits::Field_objoflistT{}, obj.objoflist);
        lambda(Traits::Field_key2T{}, obj.key2);
    }
};

template <> struct Stencil::Comparator<CLOpts1::CLOptsTest, CLOpts1::CLOptsTest>
{
    using ThisType = CLOpts1::CLOptsTest;
    static bool AreEqual([[maybe_unused]] ThisType const& obj1, [[maybe_unused]] ThisType const& obj2)
    {
        return true
               && Stencil::AreEqual(obj1.key1, obj2.key1)
               && Stencil::AreEqual(obj1.listofint, obj2.listofint)
               && Stencil::AreEqual(obj1.listoflist, obj2.listoflist)
               && Stencil::AreEqual(obj1.listofobj, obj2.listofobj)
               && Stencil::AreEqual(obj1.objoflist, obj2.objoflist)
               && Stencil::AreEqual(obj1.key2, obj2.key2)
            ;
    }
};

template <>
struct Stencil::Database::Record<CLOpts1::CLOptsTest> :
    public Stencil::Database::RecordT<CLOpts1::CLOptsTest>
{
    public:
    Stencil::Database::RecordNest<shared_string>::Type key1{};
    Stencil::Database::RecordNest<std::vector<int32_t>>::Type listofint{};
    Stencil::Database::RecordNest<std::vector<std::vector<int32_t>>>::Type listoflist{};
    Stencil::Database::RecordNest<std::vector<::CLOpts1::SimpleObj>>::Type listofobj{};
    Stencil::Database::RecordNest<::CLOpts1::ObjWithList>::Type objoflist{};
    Stencil::Database::RecordNest<shared_string>::Type key2{};
};

template <> struct Stencil::Database::RecordTraits<CLOpts1::CLOptsTest>
{
    using RecordTypes = Stencil::Database::tuple_cat_t<
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::vector<int32_t>>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::vector<std::vector<int32_t>>>::RecordTypes,
        typename Stencil::Database::RecordTraits<std::vector<::CLOpts1::SimpleObj>>::RecordTypes,
        typename Stencil::Database::RecordTraits<::CLOpts1::ObjWithList>::RecordTypes,
        typename Stencil::Database::RecordTraits<shared_string>::RecordTypes,
        std::tuple<CLOpts1::CLOptsTest>>;

    static constexpr size_t Size() { return sizeof(Stencil::Database::Record<CLOpts1::CLOptsTest>); }

    template <typename TDb>
    static void WriteToBuffer(TDb&                                                          db,
                              Stencil::Database::RWLock const&                              lock,
                              CLOpts1::CLOptsTest const&                      obj,
                              Stencil::Database::Record<CLOpts1::CLOptsTest>& rec)
    {
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.key1, rec.key1);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.listofint, rec.listofint);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.listoflist, rec.listoflist);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.listofobj, rec.listofobj);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.objoflist, rec.objoflist);
        Stencil::Database::impl::WriteToBuffer(db, lock, obj.key2, rec.key2);
    }
};

template <>
struct Stencil::Visitor<Stencil::Database::Record<CLOpts1::CLOptsTest>>
    : Stencil::VisitorT<Stencil::Database::Record<CLOpts1::CLOptsTest>>
{
    using TData  = CLOpts1::CLOptsTest;
    using Traits = Stencil::TypeTraitsForIndexable<TData>;
    using Fields = Traits::Fields;

    template <typename T, typename TLambda> static void VisitKey([[maybe_unused]] T& obj, Fields field, [[maybe_unused]] TLambda&& lambda)
    {
        switch (field)
        {
        case Fields::Field_key1: return lambda(obj.key1);
        case Fields::Field_listofint: return lambda(obj.listofint);
        case Fields::Field_listoflist: return lambda(obj.listoflist);
        case Fields::Field_listofobj: return lambda(obj.listofobj);
        case Fields::Field_objoflist: return lambda(obj.objoflist);
        case Fields::Field_key2: return lambda(obj.key2);
        case Fields::Invalid: [[fallthrough]];
        default: throw std::logic_error("Invalid Key");
        }
    }

    template <typename T, typename TLambda> static void VisitAll([[maybe_unused]] T& obj, [[maybe_unused]] TLambda&& lambda)
    {
        lambda(Traits::Field_key1T{}, obj.key1);
        lambda(Traits::Field_listofintT{}, obj.listofint);
        lambda(Traits::Field_listoflistT{}, obj.listoflist);
        lambda(Traits::Field_listofobjT{}, obj.listofobj);
        lambda(Traits::Field_objoflistT{}, obj.objoflist);
        lambda(Traits::Field_key2T{}, obj.key2);
    }
};

#endif
// SECTION END: Template specializations

// SECTION START: Inline Function Definitions
#if true

#endif
// SECTION END: Inline Function Definitions
